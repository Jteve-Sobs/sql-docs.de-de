---
title: Festlegen von Verbindungseigenschaften | Microsoft-Dokumentation
ms.custom: ''
ms.date: 07/31/2018
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: b89bebe2a6c0f8d5645ca2bbedef7624148c2feb
ms.sourcegitcommit: 467b2c708651a3a2be2c45e36d0006a5bbe87b79
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/02/2019
ms.locfileid: "53980256"
---
# <a name="setting-the-connection-properties"></a>Festlegen von Verbindungseigenschaften

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

Es gibt verschiedene Möglichkeiten, um die Eigenschaften für die Verbindungszeichenfolge anzugeben:

- Als Name=Wert-Eigenschaften in der Verbindungs-URL, wenn Verbindungen mit der DriverManager-Klasse hergestellt werden.
- Als Name = Wert-Eigenschaften in der *Eigenschaften* Parameter der Connect-Methode in der DriverManager-Klasse.
- Als Werte in der entsprechenden Festlegungsmethode der Datenquelle des Treibers. Zum Beispiel:  
  
    ```java
    datasource.setServerName(value)  
    datasource.setDatabaseName(value)  
    ```  
  
## <a name="remarks"></a>Remarks

Bei den Namen von Eigenschaften wird Groß-/Kleinschreibung unterschieden. Doppelte Eigenschaftennamen werden in der folgenden Reihenfolge aufgelöst:  
  
1. API-Argumente (wie Benutzer und Kennwort)
2. Property-Auflistung.  
3. Letzte Instanz in der Verbindungszeichenfolge.
  
Darüber hinaus sind für Eigenschaftennamen unbekannte Werte zulässig. Die Groß-/Kleinschreibung der Werte wird vom JDBC-Treiber nicht überprüft.

Synonyme sind zulässig und werden in der gleichen Reihenfolge wie doppelte Eigenschaftennamen aufgelöst.

Die folgende Tabelle enthält eine Liste aller zurzeit verfügbaren Verbindungszeichenfolgeeigenschaften für den JDBC-Treiber.

| Eigenschaft<br/>Typ<br/>Default | und Beschreibung |
| :------------------------------ | :---------- |
| accessToken<br/><br/>Zeichenfolge<br/><br/>NULL | Verwenden Sie diese Eigenschaft bei der Herstellung einer Verbindung mit einer SQL-Datenbank mithilfe eines Zugriffstokens. **AccessToken** kann nicht mithilfe der Verbindungs-URL festgelegt werden. |
| applicationIntent<br/><br/>Zeichenfolge<br/><br/>ReadWrite | Deklariert den Arbeitsauslastungstyp der Anwendung beim Herstellen einer Verbindung mit einem Server. <br/><br/>Mögliche Werte sind **ReadOnly** und **ReadWrite**. <br/><br/>Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Wiederherstellung im Notfall](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| applicationName<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>NULL | Der Anwendungsname, oder „[!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]“, wenn kein Name angegeben ist.<br/><br/>Anhand dieser Eigenschaft wird die jeweilige Anwendung in den verschiedenen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Profilerstellungs- und Protokollierungstools identifiziert. |
| Authentifizierung<br/><br/>Zeichenfolge<br/><br/>NotSpecified | Microsoft JDBC-Treiber 6.0 für SQL Server ab, gibt diese optionale Eigenschaft an, welche SQL-Authentifizierungsmethode, die für die Verbindung verwendet. Mögliche Werte sind **ActiveDirectoryIntegrated**, **ActiveDirectoryPassword**, **"sqlpassword"**, und die standardmäßige **"NotSpecified"** .<br/><br/> Verwendung **ActiveDirectoryIntegrated** für die Verbindung mit einer SQL-Datenbank mithilfe der integrierten Windows-Authentifizierung.<br/><br/> Verwendung **ActiveDirectoryPassword** für die Verbindung mit einer SQL-Datenbank mithilfe einer Azure AD-Prinzipalnamen und das Kennwort.<br/><br/> Verwendung **"sqlpassword"** für eine SQL Server über die Verbindung **Benutzername**/**Benutzer** und **Kennwort** Eigenschaften.<br/><br/> Verwendung **"NotSpecified"** Wenn keines dieser zwei Authentifizierungsmethoden erforderlich sind.<br/><br/> **Wichtig:**  Wenn die Authentifizierung auf ActiveDirectoryIntegrated festgelegt ist, müssen die folgenden zwei Bibliotheken installiert werden: **SQLJDBC_AUTH. DLL** (verfügbar in der JDBC-Treiber-Paket) und Azure Active Directory-Authentifizierungsbibliothek für SQL Server (**ADALSQL. DLL**) steht in verschiedenen Sprachen (für x X86 und amd64) aus dem Downloadcenter unter [Microsoft Active Directory-Authentifizierungsbibliothek für Microsoft SQL Server](https://www.microsoft.com/download/details.aspx?id=48742). Der JDBC-Treiber unterstützt nur Version **1.0.2028.318 und höher** für die ADALSQL. DLL.<br/><br/> **Hinweis:**  Wenn Authentifizierung-Eigenschaftensatz auf einen beliebigen Wert außer **"NotSpecified"**, verwendet der Treiber standardmäßig Verschlüsselung mit Secure Sockets Layer (SSL).<br/><br/> Informationen zum Konfigurieren von Azure Active Directory-Authentifizierung finden Sie unter [Herstellen einer Verbindung mit SQL-Datenbank mithilfe der Azure Active Directory Authentifizierung](https://azure.microsoft.com/documentation/articles/sql-database-aad-authentication/). |
| authenticationScheme<br/><br/>Zeichenfolge<br/><br/>NativeAuthentication | Gibt die Art der integrierten Sicherheit an, die für Ihre Anwendung verwendet werden soll. Mögliche Werte sind **Java Kerberos** und der standardmäßige **NativeAuthentication**.<br/><br/> Bei Verwendung **AuthenticationScheme Java Kerberos =**, Sie müssen den vollqualifizierten Domänennamen (FQDN) angeben, der **ServerName** oder **"serverspn"** Eigenschaft. Andernfalls tritt ein Fehler auf (Server in Kerberos-Datenbank nicht gefunden).<br/><br/> Weitere Informationen zur Verwendung von **AuthenticationScheme**, finden Sie unter [mithilfe von integrierten Kerberos-Authentifizierung zum Herstellen einer Verbindung mit SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| cancelQueryTimeout<br/><br/>ssNoversion<br/><br/>-1 | Microsoft JDBC-Treiber 6.4 für SQL Server ab, diese Eigenschaft kann verwendet werden, abzubrechen **QueryTimeout** legen für die Verbindung. Ausführung der Abfrage hängt und löst keine Ausnahme aus, wenn TCP-Verbindung mit SQL Server automatisch gelöscht wird. Diese Eigenschaft ist nur anwendbar, wenn "QueryTimeout" auch für die Verbindung festgelegt wird. <br/><br/>Der Treiber wartet auf die Gesamtmenge der **CancelQueryTimeout** + **QueryTimeout** Sekunden, für die Verbindung, und schließen Sie den Kanal. <br/><br/>Der Standardwert für diese Eigenschaft ist-1 und Verhalten für Warten ohne Timeout. |
| columnEncryptionSetting<br/><br/>Zeichenfolge<br/>["Enabled" &#124; "Disabled"]<br/><br/>Disabled | Legen Sie die Eigenschaft auf „Aktiviert“ fest, um das Feature Always Encrypted (AE) zu verwenden, beginnend mit dem Microsoft JDBC-Treiber 6.0 für SQL Server. Wenn AE aktiviert ist, werden vertrauliche Daten, die in verschlüsselten Datenbank-Spalten in SQL Server gespeichert sind, vom JDBC-Treiber transparent verschlüsselt und entschlüsselt.<br/><br/> Weitere Informationen zu **ColumnEncryptionSetting**, finden Sie unter [Using Always Encrypted, mit dem JDBC-Treiber](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md) Weitere Details.<br/><br/> **Hinweis:**  AE ist mit SQL Server 2016 oder höher verfügbar. |
| databaseName,<br/>Datenbank<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>NULL | Der Name der Datenbank, zu der eine Verbindung hergestellt werden soll. <br/><br/>Ohne Angabe wird eine Verbindung zur Standarddatenbank erstellt. |
| disableStatementPooling<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Flag zum angeben, wenn die Anweisung pooling verwendet werden soll. |
| enablePrepareOnFirst...<br/>PreparedStatementCall<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _enablePrepareOnFirstPreparedStatementCall_<br/><br/> Festgelegt auf "true", aktivieren Sie das vorbereitete Handle erstellen durch Aufrufen von <code>sp_prepexec</code> in der ersten Ausführung der vorbereiteten Anweisung. <br/><br/>Auf "False" festgelegt ist, so ändern Sie die erste Ausführung einer vorbereiteten Anweisung aufrufen <code>sp_executesql</code> und keine Anweisung vorbereiten, nach die zweite Ausführung geschieht es aufrufen würde <code>sp_prepexec</code> , einem vorbereiteten Anweisungshandle einzurichten. |
| encrypt<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Auf "TRUE" festgelegt, um anzugeben, dass alle zwischen Client und Server gesendeten Daten von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] eine Secure Sockets Layer (SSL)-Verschlüsselung verwenden, sofern auf dem Server ein Zertifikat installiert ist. Der Standardwert ist FALSE.<br/><br/> Ab Microsoft JDBC-Treiber 6.0 für SQL Server können Sie eine neue Verbindung Einstellung "Authentifizierung", die SSL-Verschlüsselung verwendeten besteht. <br/><br/>Weitere Informationen finden Sie unter der Eigenschaft „Authentifizierung“. |
| failoverPartner<br/><br/>Zeichenfolge<br/><br/>NULL | Der Name des Failoverservers, der in einer Datenbankspiegelungskonfiguration verwendet wird. Diese Eigenschaft wird bei einem Ausfall der Anfangsverbindung mit dem Prinzipalserver verwendet. Nachdem die Anfangsverbindung hergestellt wurde, wird diese Eigenschaft ignoriert. Diese Eigenschaft muss zusammen mit der databaseName-Eigenschaft verwendet werden.<br/><br/> **Hinweis:** Der Treiber unterstützt keine Angabe der Portnummer der Serverinstanz für die Failoverpartnerinstanz innerhalb der failoverPartner-Eigenschaft in der Verbindungszeichenfolge. Die Eigenschaften serverName, instanceName und portNumber der Prinzipalserverinstanz und die failoverPartner-Eigenschaft der Failoverpartnerinstanz können nicht in der gleichen Verbindungszeichenfolge angegeben werden.<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, kann die Datenbankspiegelung nicht verwendet werden. Weitere Informationen finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Notfallwiederherstellung](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) |
| fips<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>„FALSE“ | Diese Eigenschaft sollte sein, für die FIPS JVM aktiviert **"true"**. |
| fipsProvider<br/><br/>Zeichenfolge<br/><br/>NULL | FIPS-Anbieter in JVM konfiguriert. Z. B. BCFIPS oder SunPKCS11-NSS. Ausführliche Informationen finden Sie in Version 6.4.0 - entfernt [hier](https://github.com/Microsoft/mssql-jdbc/pull/460). |
| gsscredential<br/><br/>org.ietf.jgss.GSSCredential<br/><br/>NULL | Microsoft JDBC-Treiber 6.2 für SQL Server ab, können die Benutzeranmeldeinformationen für die eingeschränkte Kerberos-Delegierung verwendet werden in dieser Eigenschaft übergeben werden. <br/><br/>Dies sollte verwendet werden, mit **IntegratedSecurity** als **"true"** und **Java Kerberos** **Authenticationscheme**. |
| hostNameInCertificate<br/><br/>Zeichenfolge<br/><br/>NULL | Der Hostname, der beim Überprüfen des [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-SSL-Zertifikats verwendet werden soll.<br/><br/> Wenn die hostNameInCertificate-Eigenschaft nicht angegeben oder auf NULL festgelegt ist, verwendet [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] den **serverName**-Eigenschaftswert der Verbindungs-URL als Hostnamen zum Überprüfen des [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-SSL-Zertifikats.<br/><br/> **Hinweis:**  Diese Eigenschaft wird verwendet, in Kombination mit der **verschlüsseln**/**Authentifizierung** Eigenschaften und die **TrustServerCertificate** Eigenschaft. Diese Eigenschaft wirkt sich auf die zertifikatsüberprüfung, wenn und nur wenn die Verbindung Secure Sockets Layer (SSL)-Verschlüsselung verwendet und die **TrustServerCertificate** auf "False" festgelegt ist. Stellen Sie sicher, dass der an **hostNameInCertificate** übergebene Name für eine erfolgreiche SSL-Verbindung exakt dem CN (Common Name, allgemeiner Name) oder dem DNS-Namen im SAN (Subject Alternate Name, Subjektalternativname) im Serverzertifikat entspricht. Weitere Informationen finden Sie unter [Grundlegendes zur SSL-Unterstützung](../../connect/jdbc/understanding-ssl-support.md). |
| INSTANCENAME<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>NULL | Der Name der [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Instanz, mit der eine Verbindung hergestellt werden soll. Ohne Angabe wird eine Verbindung mit der Standardinstanz erstellt. Wenn "instanceName" und "port" angegeben werden, finden Sie nützliche Informationen in den Hinweisen für "port".<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, kann die **instanceName**-Verbindungseigenschaft nicht verwendet werden. Finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Wiederherstellung im Notfall](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) für Weitere Informationen. |
| integratedSecurity<br/><br/>boolean<br/>["true"&#124;"false"]<br/><br/>false | Festgelegt auf "true", um anzugeben, dass die Windows-Anmeldeinformationen, mit denen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] auf Windows-Betriebssystemen. Wenn diese Eigenschaft auf "true" gesetzt ist, sucht der JDBC-Treiber im Cache für Anmeldeinformationen des lokalen Computers die Anmeldeinformationen, die bei der Anmeldung beim Computer oder Netzwerk angegeben wurden.<br/><br/> Klicken Sie auf "True" festgelegt ist (mit **Authenticationscheme Java Kerberos =**), um anzugeben, dass die Kerberos-Anmeldeinformationen, mit denen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Weitere Informationen zur Kerberos-Authentifizierung finden Sie unter [Verwenden der integrierten Kerberos-Authentifizierung für Verbindungen mit SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). <br/><br/> Ist diese Eigenschaft auf "false" gesetzt, müssen Benutzername und Kennwort angegeben werden. |
| jaasConfigurationName<br/><br/>Zeichenfolge<br/><br/>SQLJDBCDriver | Microsoft JDBC-Treiber 6.2 für SQL Server ab, haben jede Verbindung mit SQL Server eine eigene Datei JAAS Login Configuration zu, um Kerberos-Verbindung herzustellen. Name der Konfigurationsdatei Anmeldung kann über diese Eigenschaft übergeben werden. <br/> Standardmäßig legt Treiber Eigenschaft `useDefaultCcache = true` für IBM-JVMs und `useTicketCache = true` für andere JVMs. |
| keyStoreAuthentication<br/><br/>Zeichenfolge<br/><br/>NULL | Microsoft JDBC-Treiber 6.0 für SQL Server ab, diese Eigenschaft gibt welche Schlüsselspeicher nahtlos für die Verbindung mit Always Encrypted eingerichtet und bestimmt einen Authentifizierungsmechanismus verwendet, um den Schlüsselspeicher zu authentifizieren. Microsoft JDBC-Treiber 6.0 für SQL Server unterstützt Einstellung sich von der Java-Key Store nahtlos mit dieser Eigenschaft, die für die Sie festlegen müssen "**KeyStoreAuthentication = JavaKeyStorePassword**". Beachten Sie, dass um diese Eigenschaft verwenden zu können, Sie auch festlegen müssen der **KeyStoreLocation** und **KeyStoreSecret** Eigenschaften für die Java-Key Store. <br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem ODBC-Treiber](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreLocation<br/><br/>Zeichenfolge<br/><br/>NULL | Wenn **KeyStoreAuthentication = JavaKeyStorePassword**, **KeyStoreLocation** identifiziert den Pfad zu der Java-Keystore-Datei, in der die spaltenhauptschlüssel mit Always Encrypted verwendet werden gespeichert Daten. Beachten Sie, dass der Pfad auf den Dateinamen des Keystores enthalten muss.<br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem ODBC-Treiber](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreSecret<br/><br/>Zeichenfolge<br/><br/>NULL | Wenn **KeyStoreAuthentication = JavaKeyStorePassword**, **KeyStoreSecret** Eigenschaft identifiziert, das Kennwort für den Keystore sowie für den Schlüssel zu verwenden. Beachten Sie, dass für die Verwendung der Java-Key Store Keystore und das Kennwort für den Schlüssel identisch sein müssen.<br/><br/>Weitere Informationen finden Sie unter [Verwenden von Always Encrypted mit dem ODBC-Treiber](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| lastUpdateCount<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Wenn der Wert dieser Eigenschaft auf "true" gesetzt ist, wird nur die letzte Updatezählung einer SQL-Anweisungen zurückgegeben, die an den Server übergeben wurde. Die Eigenschaft kann in einzelnen SELECT-, INSERT- oder DELETE-Anweisungen verwendet werden, wenn zusätzliche Updatezählungen von Servertriggern ignoriert werden sollen. Wenn diese Eigenschaft auf "false" gesetzt ist, werden alle Updatezählungen zurückgegeben, einschließlich der von Servertriggern.<br/><br/> **Hinweis:**  Diese Eigenschaft ist nur gültig, wenn sie mit den [executeUpdate](../../connect/jdbc/reference/executeupdate-method-sqlserverstatement.md)-Methoden verwendet wird. Alle anderen Ausführungsmethoden geben alle Ergebnisse und Updatezählungen zurück. Diese Eigenschaft betrifft nur Updatezählungen, die von Servertriggern zurückgegeben werden. Sie betrifft keine Resultsets oder Fehler, die Folge der Ausführung eines Triggers sind. |
| lockTimeout<br/><br/>ssNoversion<br/><br/>-1 | Die Wartezeit in Millisekunden, bevor die Datenbank ein Sperrtimeout meldet. Standardmäßig wird unendlich lang gewartet. Wird dieser Wert angegeben, wird er als Standardwert für alle Anweisungen der Verbindung verwendet. Beachten Sie, dass **Statement.setQueryTimeout()** können verwendet werden, um das Timeout für bestimmte Anweisungen festgelegt. Der Wert kann auch 0 sein (keine Wartezeit). |
| loginTimeout<br/><br/>ssNoversion<br/>[0..65535]<br/><br/>15 | Die Wartezeit in Sekunden, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet. Mit dem Wert 0 wird angegeben, dass das Timeout das Standardsystemtimeout ist, das standardmäßig auf 15 Sekunden festgelegt ist. Ein Wert ungleich 0 gibt die Wartezeit in Sekunden an, bevor der Treiber bei einem Verbindungsfehler ein Timeout meldet.<br/><br/> Wenn Sie in der **Server**-Verbindungseigenschaft den Namen eines virtuellen Netzwerks angeben, müssen Sie einen Timeoutwert von mindestens drei Minuten angeben, damit ausreichend Zeit für die Herstellung einer Failoververbindung vorhanden ist. Finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Wiederherstellung im Notfall](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) für Weitere Informationen. |
| multiSubnetFailover<br/><br/>Boolean<br/><br/>false | Geben Sie immer **multiSubnetFailover=true** an, wenn Sie eine Verbindung mit dem Verfügbarkeitsgruppenlistener einer [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]-Verfügbarkeitsgruppe oder einer [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]-Failoverclusterinstanz herstellen. **multiSubnetFailover=true** konfiguriert [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)], um eine schnellere Erkennung sowie die Verbindung zu dem (gerade) aktiven Server zu gewährleisten. Mögliche Werte sind true und false. Finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Wiederherstellung im Notfall](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) für Weitere Informationen.<br/><br/> Sie können auf die **multiSubnetFailover**-Verbindungseigenschaft mit [getPropertyInfo](../../connect/jdbc/reference/getpropertyinfo-method-sqlserverdriver.md), [getMultiSubnetFailover](../../connect/jdbc/reference/getmultisubnetfailover-method-sqlserverdatasource.md) und [setMultiSubnetFailover](../../connect/jdbc/reference/setmultisubnetfailover-method-sqlserverdatasource.md) programmgesteuert zugreifen.<br/><br/> **Hinweis:**  Microsoft JDBC-Treiber 6.0 für SQL Server ab, es ist nicht mehr erforderlich, legen Sie **MultiSubnetFailover** auf "true", Herstellen der Verbindung mit einem Verfügbarkeitsgruppen-Listener. Neue Eigenschaft **TransparentNetworkIPResolution**, die standardmäßig aktiviert ist, wird die Erkennung und Verbindung mit dem (gerade) aktiven Server enthält. |
| packetSize<br/><br/>ssNoversion<br/>[-1 &#124; 0 &#124; 512..32767]<br/><br/>8000 | Die Netzwerkpaketgröße in Byte, die für die Kommunikation mit SQL Server verwendet wird. Ein Wert von -1 gibt an, dass die Standardpaketgröße des Servers verwendet wird. Ein Wert von 0 gibt an, dass der Maximalwert verwendet wird, d. h. 32767. Wenn diese Eigenschaft auf einen Wert außerhalb des zulässigen Bereichs festgelegt wird, wird eine Ausnahme ausgelöst.<br/><br/> **Wichtig:**  Das Verwenden der packetSize-Eigenschaft bei aktivierter Verschlüsselung (encrypt=true) wird nicht empfohlen. Andernfalls könnte der Treiber einen Verbindungsfehler auslösen. Weitere Informationen finden Sie unter der [setPacketSize](../../connect/jdbc/reference/setpacketsize-method-sqlserverdatasource.md)-Methode der [SQLServerDataSource](../../connect/jdbc/reference/sqlserverdatasource-class.md)-Klasse. |
| Kennwort<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>NULL | Das Datenbankkennwort, bei der Verbindung mit SQL-Benutzer und Kennwort.<br/>Für die Kerberos-Verbindung mit Prinzipalname und Kennwort wird diese Eigenschaft auf Kerberos-Prinzipal-Kennwort festgelegt. |
| portNumber,<br/>port<br/><br/>ssNoversion<br/>[0..65535]<br/><br/>1433 | Der Port, der von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] überwacht wird. Wird die Portnummer in der Verbindungszeichenfolge angegeben, erfolgt keine Anforderung an den SQL-Browser. Wenn "port" und "instanceName" angegeben werden, wird die Verbindung zum angegebenen Port hergestellt. **instanceName** wird jedoch überprüft. Wenn „instanceName“ und Port nicht übereinstimmen, wird ein Fehler ausgegeben.<br/><br/> **Wichtig:** Es wird empfohlen, immer die Portnummer anzugeben, da dies sicherer ist als die Verwendung von SQLbrowser. |
| queryTimeout<br/><br/>ssNoversion<br/><br/>-1 | Auf einer Abfrage ist die Anzahl der Sekunden wartet, bevor ein Timeout aufgetreten. Der Standardwert ist-1 und bedeutet, unendliches Timeout dass an. Die Einstellung mit 0 auch impliziert, um unbegrenzt zu warten. |
| responseBuffering<br/><br/>Zeichenfolge<br/>["full" &#124; "adaptive"]<br/><br/>adaptive | Wenn diese Eigenschaft auf "adaptive" festgelegt ist, werden nach Bedarf so wenig Daten wie möglich gepuffert. Der Standardmodus lautet „adaptiv“.<br/><br/> Wenn diese Eigenschaft auf "full" festgelegt ist, wird das gesamte Resultset vom Server gelesen, wenn eine Anweisung ausgeführt wird.<br/><br/> **Hinweis:** Nach dem Upgrade des JDBC-Treibers von Version 1.2 ist "adaptive" das standardmäßige Pufferverhalten. Wenn die responseBuffering-Eigenschaft in der Anwendung nie festgelegt wurde und Sie das Standardverhalten aus Version 1.2 in der Anwendung beibehalten möchten, müssen Sie die responseBufferring-Eigenschaft entweder in den Verbindungseigenschaften oder mit der [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md)-Methode des [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md)-Objekts auf "full" festlegen. |
| selectMethod<br/><br/>Zeichenfolge<br/>["direct" &#124; "cursor"]<br/><br/>direct | Wenn diese Eigenschaft auf "cursor" festgelegt wird, wird bei **TYPE_FORWARD_ONLY**- und **CONCUR_READ_ONLY**-Cursorn für jede Abfrage, die für die Verbindung erstellt wird, ein Datenbankcursor erstellt. Diese Eigenschaft ist normalerweise nur dann erforderlich, wenn die Anwendung umfangreiche Resultsets generiert, die nicht vollständig in den Clientspeicher übernommen werden können. Wird diese Eigenschaft "cursor" eingestellt, wird nur eine begrenzte Anzahl von Resultsetzeilen in den Clientspeicher übernommen. <br/><br/>Standardmäßig werden alle Resultsetzeilen in den Clientspeicher übernommen. Dieses Verhalten weist die höchste Leistung auf, wenn die Anwendung alle Zeilen verarbeitet. |
| sendStringParameters...<br/>AsUnicode<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *sendStringParametersAsUnicode*<br/><br/>Wenn die **sendStringParametersAsUnicode**-Eigenschaft auf „TRUE“ festgelegt ist, werden String-Parameter im Unicode-Format an den Server gesendet.<br/><br/> Wenn die **sendStringParametersAsUnicode**-Eigenschaft auf „FALSE“ festgelegt ist, werden String-Parameter nicht im Unicode-Format, sondern in einem anderen Format wie ASCII/MBCS an den Server gesendet.<br/><br/> Der Standardwert für die **sendStringParametersAsUnicode**-Eigenschaft lautet „TRUE“.<br/><br/> **Hinweis:** Die **sendStringParametersAsUnicode**-Eigenschaft ist nur aktiviert, wenn ein Parameterwert mit den JDBC-Typen **CHAR**, **VARCHAR** oder **LONGVARCHAR** gesendet wird. Di neuen JDBC 4.0-Methoden für nationale Zeichensätze wie setNString, setNCharacterStream und setNClob der [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md)- und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md)-Klasse senden ihre Parameterwerte unabhängig vom Wert dieser Eigenschaft immer im Unicode-Format an den Server.<br/><br/> Zur Erzielung einer optimalen Leistung mit den JDBC-Datentypen **CHAR**, **VARCHAR** und **LONGVARCHAR** sollte in einer Anwendung die **sendStringParametersAsUnicode**-Eigenschaft auf „FALSE“ festgelegt werden, und die Methoden für nicht nationale Zeichensätze setString, setCharacterStream und setClob der [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md)- und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md)-Klasse sollten verwendet werden.<br/><br/> Wenn die **sendStringParametersAsUnicode**-Eigenschaft in der Anwendung auf „FALSE“ festgelegt und eine Methode für nicht nationale Zeichensätze für den Zugriff auf Unicode-Datentypen auf Serverseite verwendet wird (z.B. **nchar**, **nvarchar** und **ntext**), gehen möglicherweise Daten verloren, wenn die Datenbanksortierung die von der Methode für nicht nationale Zeichensätze im String-Parameter übergebenen Zeichen nicht unterstützt.<br/><br/> Beachten Sie, dass eine Anwendung die SetNString SetNCharacterStream und SetNClob-Methoden für nationale Zeichensätze von verwenden, sollte die [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) und [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) für Klassen die **NCHAR**, **NVARCHAR**, und **LONGNVARCHAR** JDBC-Datentypen. |
| sendTimeAsDatetime<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | Diese Eigenschaft wurde in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] JDBC Driver 3.0 hinzugefügt.<br/><br/> Festgelegt auf "true", zum Senden von java.sql.Time-Werte an den Server als [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **"DateTime"** Werte. <br/>Auf "False" festgelegt, um das Senden von java.sql.Time-Werte an den Server als [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **Zeit** Werte.<br/><br/> Der Standardwert für diese Eigenschaft ist derzeit "true", und es kann sich in einem zukünftigen Release ändern.<br/><br/> Weitere Informationen zur Funktionsweise des [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] konfiguriert java.sql.Time-Werte vor dem Senden an den Server, finden Sie unter [konfigurieren wie java.sql.Time-Werte werden an den Server gesendeten](../../connect/jdbc/configuring-how-java-sql-time-values-are-sent-to-the-server.md). |
| serverName,<br/>server<br/><br/>Zeichenfolge<br/><br/>NULL | Der Computer, auf dem [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ausgeführt wird.<br/><br/> Sie können auch den Namen des virtuellen Netzwerks für eine [!INCLUDE[ssHADR](../../includes/sshadr_md.md)]-Verfügbarkeitsgruppe angeben. Finden Sie unter [JDBC Driver-Unterstützung für hohe Verfügbarkeit, Wiederherstellung im Notfall](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) für Weitere Informationen. |
| serverNameAsACE<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Legen Sie, beginnend mit dem Microsoft JDBC-Treiber 6.0 für SQL Server, die Eigenschaft auf „true“ fest, um anzugeben, dass der Treiber für die Verbindung den Unicodeservernamen in eine ASCII-kompatible Codierung übersetzen soll (Punycode). Wenn diese Einstellung auf „false“ festgelegt ist, stellt der Treiber die Verbindung unter Verwendung des vom Benutzer bereitgestellten Servernamens her.<br/><br/> Finden Sie unter [internationale Funktionen des JDBC-Treibers](../../connect/jdbc/international-features-of-the-jdbc-driver.md) Weitere Details. |
| serverPreparedStatement...<br/>DiscardThreshold<br/><br/>Integer<br/><br/>10 | *serverPreparedStatementDiscardThreshold*<br/><br/>Ab JDBC-Treiber 6.2 für SQL Server können diese Eigenschaft kann verwendet werden zu steuern, wie viele ausstehende Anweisung Verwerfen von Aktionen vorbereitet (<code>sp_unprepare</code>) pro Verbindung ausstehend sein kann, bevor ein Aufruf zum Bereinigen der ausstehende Handles auf dem Server ausgeführt wird . <br/><br/> Wenn diese Eigenschaft, um festgelegt wird &lt;= 1, unprepare Aktionen sofort auf Schließen die vorbereitete Anweisung ausgeführt werden. Wenn sie, um festgelegt ist &gt;1, die diese Aufrufe einem zusammengefasst Batch sind um Mehraufwand Sp_unprepare oft aufrufen zu vermeiden. |
| serverSpn<br/><br/>Zeichenfolge<br/><br/>NULL | Ab dem Microsoft JDBC-Treiber 4.2 für SQL Server kann diese optionale Eigenschaft verwendet werden, um den Dienstprinzipalnamen (Service Principal Name, SPN) für eine Java-Kerberos-Verbindung anzugeben.  Es dient in Verbindung mit **AuthenticationScheme**.<br/><br/> Der SPN kann in der Form „MSSQLSvc/fqdn:port@REALM“ angegeben werden, wobei „fqdn“ den vollqualifizierten Domänennamen, „port“ die Portnummer und „REALM“ den Kerberos-Bereich des SQL Server-Computers in Großbuchstaben darstellen.<br/><br/> Hinweis: Die Angabe „@REALM“ ist optional, wenn der Standardbereich des Clients (gemäß Angabe in der Kerberos-Konfiguration) mit dem Kerberos-Bereich des SQL Server-Computers übereinstimmt.<br/><br/> Weitere Informationen zur Verwendung von **"serverspn"** mit Java Kerberos finden Sie unter [mithilfe von integrierten Kerberos-Authentifizierung zum Herstellen einer Verbindung mit SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| StatementPooling...<br/>CacheSize<br/><br/>ssNoversion<br/><br/>0 | *statementPoolingCacheSize*<br/><br/>Ab JDBC-Treiber 6.4 für SQL Server, kann diese Eigenschaft verwendet werden, vorbereitete Anweisung behandeln Caching im Treiber zu aktivieren. <br/><br/>Diese Eigenschaft definiert die Größe des Caches für anweisungspools. <br/><br/>Diese Eigenschaft kann nur verwendet werden, zusammen mit **DisableStatementPooling** Connection-Eigenschaft der auf "False" festgelegt werden soll. Festlegen von **DisableStatementPooling** auf "True" oder **statementpoolingcachesize-Wert** auf 0 verhindert, die vorbereitete Anweisung das caching.|
| socketTimeout<br/><br/>ssNoversion<br/><br/>0 | Die Anzahl der Millisekunden, die gewartet wird, bevor für einen Socket ist ein Timeout aufgetreten ist, lesen oder übernehmen. Der Standardwert ist 0, d. unendliches Timeout h. an. |
| sslProtocol<br/><br/>Zeichenfolge<br/><br/>TLS | Ab JDBC-Treiber 6.4 für SQL Server, kann diese Eigenschaft verwendet, an der TLS-Protokoll, bei der sicheren Verbindung berücksichtigt werden. <br/>Folgende Werte sind möglich: **TLS**, **TLSv1**, **TLSv1. 1**, und **TLSv1. 2**. <br/><br/>Weitere Informationen finden Sie unter [SSLProtocol](https://github.com/Microsoft/mssql-jdbc/wiki/SSLProtocol). |
| transparentNetwork...<br/>IPResolution<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *transparentNetworkIPResolution*<br/><br/>Microsoft JDBC-Treiber 6.0 für SQL Server ab, enthält diese Eigenschaft, schnellere Erkennung sowie die Verbindung mit dem (gerade) aktiven Server. Mögliche Werte sind "true" und "false", "true" ist der Standardwert.<br/><br/> Vor Microsoft JDBC-Treiber 6.0 für SQL Server, musste eine Anwendung legen Sie die Verbindungszeichenfolge einschließen "MultiSubnetFailover = True", um anzugeben, dass sie eine Verbindung mit einer AlwaysOn-Verfügbarkeitsgruppe herstellt wurde. Festlegen, ohne die **MultiSubnetFailover** Verbindungsschlüsselwörter auf "True", eine Anwendung tritt möglicherweise einen Timeout beim Herstellen einer Verbindung mit einer AlwaysOn-Verfügbarkeitsgruppe. Microsoft JDBC-Treiber 6.0 für SQL Server ab, muss eine Anwendung nicht MultiSubnetFailover auf mehr "true" festgelegt. <br/><br/>**Hinweis:** Wenn TransparentNetworkIPResolution = "true", der ersten Verbindung Versuch verwendeten 500 ms als das Timeout. Alle nachfolgenden Verwendungsversuche verwenden die gleiche Timeoutlogik, wie durch die MultiSubnetFailover-Eigenschaft verwendet. |
| trustManagerClass<br/><br/>Zeichenfolge<br/><br/>NULL | Die vollqualifizierten Namen einer benutzerdefinierten <code>javax.net.ssl.TrustManager</code> Implementierung. |
| trustManager...<br/>ConstructorArg<br/><br/>Zeichenfolge<br/><br/>NULL | *trustManagerConstructorArg*<br/><br/>Ein optionales Argument für die Übergabe an den Konstruktor der TrustManager. TrustManagerClass angegeben ist, und eine verschlüsselte Verbindung angefordert wird, wird die benutzerdefinierte TrustManager statt des Standardsystems JVM-Keystore-basierte TrustManager verwendet. |
| trustServerCertificate<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Legen Sie den Wert „TRUE“ fest, um anzugeben, dass [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] das [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-SSL-Zertifikat nicht überprüft.<br/><br/> Bei „TRUE“ wird dem [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-SSL-Zertifikat automatisch vertraut, wenn die Kommunikationsebene mit SSL verschlüsselt ist.<br/><br/> Bei "false", die [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] überprüft das SSL-Zertifikat. Wenn bei der Überprüfung des Serverzertifikats ein Fehler auftritt, löst der Treiber einen Fehler aus und trennt die Verbindung. Der Standardwert ist FALSE. Stellen Sie sicher, dass der an **serverName** übergebene Name für eine erfolgreiche SSL-Verbindung exakt dem CN (Common Name, allgemeiner Name) oder dem DNS-Namen im Subjektalternativnamen im Serverzertifikat entspricht. Weitere Informationen finden Sie unter [Grundlegendes zur SSL-Unterstützung](../../connect/jdbc/understanding-ssl-support.md).<br/><br/> **Hinweis:** Diese Eigenschaft wird verwendet, in Kombination mit der **verschlüsseln**/**Authentifizierung** Eigenschaften. Diese Eigenschaft wirkt sich nur auf die Server SSL-zertifikatüberprüfung aus, wenn die Verbindung über SSL-Verschlüsselung verwendet. |
| trustStore<br/><br/>Zeichenfolge<br/><br/>NULL | Der Pfad (einschließlich Dateiname) zur trustStore-Zertifikatsdatei. Die trustStore-Datei enthält die Liste der Zertifikate, denen der Client vertraut.<br/><br/> Wenn diese Eigenschaft nicht angegeben oder auf NULL festgelegt ist, verwendet der Treiber die Suchregeln der Trust-Manager-Factory, um den zu verwendenden Zertifikatspeicher zu ermitteln.<br/><br/> **Die Standard-SunX509 TrustManagerFactory versucht, die vertrauenswürdigen Informationen in der folgenden Suchreihenfolge zu suchen:**<br/><br/> Eine von der Java Virtual Machine (JVM)-Systemeigenschaft "javax.net.ssl.trustStore" angegebene Datei<br/><br/> Datei „&lt;java-home&gt;/lib/security/jssecacerts“.<br/><br/> Datei „&lt;java-home&gt;/lib/security/cacerts“.<br/><br/> <br/><br/> Weitere Informationen finden Sie in der Dokumentation zur SunX509 TrustManager-Schnittstelle auf der Website von Sun Microsystems.<br/><br/> **Hinweis:** Diese Eigenschaft wirkt sich nur auf der Suche nach TrustStore Zertifikat, wenn die Verbindung über SSL-Verschlüsselung verwendet und die **TrustServerCertificate** Eigenschaft auf "False" festgelegt ist. |
| trustStorePassword<br/><br/>Zeichenfolge<br/><br/>NULL | Das Kennwort, das zum Überprüfen der Integrität der trustStore-Daten verwendet wird.<br/><br/> Wenn die trustStore-Eigenschaft festgelegt ist, die trustStorePassword-Eigenschaft jedoch nicht festgelegt wurde, wird die Integrität von "trustStore" nicht überprüft.<br/><br/> Wenn die trustStore-Eigenschaft und die trustStorePassword-Eigenschaft nicht angegeben wurden, verwendet der Treiber die JVM-Systemeigenschaften „javax.net.ssl.trustStore“ und „javax.net.ssl.trustStorePassword“. Wenn die Systemeigenschaft „javax.net.ssl.trustStorePassword“ nicht angegeben ist, wird die Integrität von „trustStore“ nicht überprüft.<br/><br/> Wenn die trustStore-Eigenschaft nicht festgelegt ist, die trustStorePassword-Eigenschaft jedoch festgelegt ist, verwendet der JDBC-Treiber die von „javax.net.ssl.trustStore“ angegebene Datei als Vertrauensspeicher, und die Integrität des Vertrauensspeichers wird mithilfe des angegebenen „trustStorePassword“ überprüft. Dies kann erforderlich sein, wenn in der Clientanwendung das Kennwort nicht in der JVM-Systemeigenschaft gespeichert werden soll.<br/><br/> **Hinweis:**  Die TrustStorePassword-Eigenschaft wirkt sich nur auf der Suche nach TrustStore Zertifikat, wenn die Verbindung über SSL-Verbindung verwendet und die **TrustServerCertificate** Eigenschaft auf "False" festgelegt ist. |
| trustStoreType<br/><br/>Zeichenfolge<br/><br/>JKS | Legen Sie diese Eigenschaft an Vertrauenswürdigkeit Speichertyp für FIPS-Modus verwendet werden soll. <br/><br/>Mögliche Werte sind entweder **PKCS12** oder Typ, der von FIPS-Anbieter definiert. |
| useBulkCopyFor...<br/>BatchInsert<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _useBulkCopyForBatchInsert_<br/><br/> Microsoft JDBC-Treiber 7.0 für SQL Server ab, diese Verbindungseigenschaft kann aktiviert werden, die API für Massenkopieren verwenden bei mithilfe von Insert-Vorgängen für Batch <code>java.sql.PreparedStatement</code> zur leistungsverbesserung. <br/><br/>Dieses Feature funktioniert nur, wenn der Zielserver des Typs ist **Azure Data Warehouse**. Es ist standardmäßig deaktiviert, legen Sie diese Eigenschaft auf "True", um dieses Feature zu aktivieren. <br/></br> **Wichtiger Hinweis:** dieses Feature unterstützt nur vollständig parametrisierte Abfragen zum Einfügen. Wenn die Abfragen zum Einfügen von anderen SQL-Abfragen kombiniert werden, oder Daten Werte enthalten, wird das Ausführung auf dem grundlegenden Batch Insert-Vorgang zurückgreifen. <br/><br/> Weitere Informationen zur Verwendung dieser Eigenschaft finden Sie unter [mithilfe von API für Massenkopieren für Batch-Insert-Vorgang](use-bulk-copy-api-batch-insert-operation.md)|
| userName,<br/>user<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>NULL | Der Datenbankbenutzer, bei der Verbindung mit SQL-Benutzer und Kennwort.<br/><br/>Für die Kerberos-Verbindung mit Prinzipalname und Kennwort wird diese Eigenschaft auf Kerberos-Prinzipalname festgelegt. |
| workstationID<br/><br/>Zeichenfolge<br/>[&lt;=128 char]<br/><br/>&lt;leere Zeichenfolge&gt; | Die ID der Arbeitsstation. Anhand dieser Eigenschaft wird die jeweilige Arbeitsstation in den verschiedenen [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Profilerstellungs- und Protokollierungstools identifiziert. <br/><br/>Wenn keine Angabe erfolgt, wird die &lt;leere Zeichenfolge&gt; verwendet. |
| xopenStates<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | Legen Sie diese Eigenschaft auf "true" fest, um anzugeben, dass der Treiber in Ausnahmen XOPEN-kompatible Statuscodes zurückgibt. <br/><br/>Standardmäßig werden SQL 99-Statuscodes zurückgegeben. |
| &nbsp; | &nbsp; |

> [!NOTE]  
> [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] akzeptiert die standardmäßigen Serverwerte für Verbindungseigenschaften, außer „ANSI_DEFAULTS“ und „IMPLICIT_TRANSACTIONS“. [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] legt „ANSI_DEFAULTS“ automatisch auf „ON“ und „IMPLICIT_TRANSACTIONS“ automatisch auf „OFF“ fest.

> [!Important]
> Wenn Authentifizierung ActiveDirectoryPassword festgelegt ist, muss die folgende Bibliotheken in Classpath enthalten sein: [Azure-Activedirectory-Library-for-Java](https://github.com/AzureAD/azure-activedirectory-library-for-java). Es befinden sich [Maven-Repository](https://mvnrepository.com/artifact/com.microsoft.azure/adal4j). Die einfachste Möglichkeit zum Herunterladen der Bibliothek und ihrer Abhängigkeiten ist Maven verwenden: 
> 1. Installieren Sie zunächst auf Ihrem System Maven 
> 2. Wechseln Sie zu der [GitHub-Seite](https://github.com/Microsoft/mssql-jdbc) des Treibers
> 3. Laden Sie die Datei "pom.xml"
> 4. Führen Sie den folgenden Maven-Befehl zum Herunterladen der Bibliothek und ihre Abhängigkeiten: `mvn dependency:copy-dependencies`

## <a name="see-also"></a>Weitere Informationen

[Verbinden von SQL Server mit dem JDBC-Treiber](../../connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver.md)  
[FIPS-Modus](../../connect/jdbc/fips-mode.md)
