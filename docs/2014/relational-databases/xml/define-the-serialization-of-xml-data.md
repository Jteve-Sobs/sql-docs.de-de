---
title: Definieren der Serialisierung von XML-Daten | Microsoft-Dokumentation
ms.custom: ''
ms.date: 10/18/2019
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- entitization rules [XML in SQL Server]
- serialization
- reparsing serialized XML structures
- encoding [XML in SQL Server]
- XML [SQL Server], serialization
- xml data type [SQL Server], serialization
- typed XML
ms.assetid: 42b0b5a4-bdd6-4a60-b451-c87f14758d4b
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 39f3ccc462fb063ecb314b1e9968dcfa8a095cbb
ms.sourcegitcommit: 82a1ad732fb31d5fa4368c6270185c3f99827c97
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/21/2019
ms.locfileid: "72688887"
---
# <a name="define-the-serialization-of-xml-data"></a>Definieren der Serialisierung von XML-Daten
  Beim expliziten oder impliziten Umwandeln des XML-Datentyps in eine SQL-Zeichenfolge oder einen Bin√§rtyp wird der Inhalt des XML-Datentyps entsprechend der in diesem Thema beschriebenen Regeln serialisiert.  
  
## <a name="serialization-encoding"></a>Serialisierungscodierung  
 Wenn der SQL-Zieltyp VARBINARY ist, erfolgt die Serialisierung des Ergebnisses in UTF-16 mit einer UTF-16-Markierung f√ºr die Bytereihenfolge am Anfang, jedoch ohne eine XML-Deklaration. Wenn der Zieltyp zu klein ist, wird ein Fehler ausgel√∂st.  
  
 Zum Beispiel:  
  
```sql
select CAST(CAST(N'<Œî/>' as XML) as VARBINARY(MAX))  
```  
  
 Dies ist das Ergebnis:  
  
```  
0xFFFE3C0094032F003E00  
```  
  
 Wenn der SQL-Zieltyp NVARCHAR oder NCHAR ist, erfolgt die Serialisierung des Ergebnisses in UTF-16 ohne die Markierung f√ºr die Bytereihenfolge am Anfang und ohne eine XML-Deklaration. Wenn der Zieltyp zu klein ist, wird ein Fehler ausgel√∂st.  
  
 Zum Beispiel:  
  
```sql
select CAST(CAST(N'<Œî/>' as XML) as NVARCHAR(MAX))  
```  
  
 Dies ist das Ergebnis:  
  
```  
<Œî/>  
```  
  
 Wenn der SQL-Zieltyp VARCHAR oder NCHAR ist, erfolgt die Serialisierung des Ergebnisses in der Codierung, die der Codepage der Datenbanksortierung entspricht, ohne Markierung zur Bytereihenfolge oder XML-Deklaration. Wenn der Zieltyp zu klein ist oder der Wert nicht zur Codeseite der Zielsortierung zugeordnet werden kann, wird ein Fehler ausgel√∂st.  
  
 Zum Beispiel:  
  
```sql
select CAST(CAST(N'<Œî/>' as XML) as VARCHAR(MAX))  
```  
  
 Dies kann zu einem Fehler f√ºhren, wenn die Codepage der aktuellen Sortierung das Unicode-Zeichen &#x10300;nicht darstellen kann, oder Sie stellt Sie in der spezifischen Codierung dar.  
  
 Beim Zur√ºckgeben der XML-Ergebnisse an die Clientseite werden die Daten in UTF-16-Codierung gesendet. Der clientseitige Anbieter macht die Daten dann entsprechend seinen API-Regeln verf√ºgbar.  
  
## <a name="serialization-of-the-xml-structures"></a>Serialisierung der XML-Strukturen  
 Der Inhalt eines **xml** -Datentyps wird auf die herk√∂mmliche Art und Weise serialisiert. Das hei√üt konkret, dass Elementknoten dem Elementmarkup zugeordnet und Textknoten dem Textinhalt zugeordnet werden. Die Umst√§nde, unter denen die Zeichen in Entit√§ten ge√§ndert werden, und die Modalit√§ten beim Serialisieren von atomaren Werten werden in den folgenden Abschnitten beschrieben.  
  
## <a name="entitization-of-xml-characters-during-serialization"></a>√Ñndern von XML-Zeichen in Entit√§ten bei der Serialisierung  
 Jede serialisierte XML-Struktur muss in der Lage sein, neu analysiert zu werden. Deshalb m√ºssen einige Zeichen so serialisiert werden, dass sie in eine Entit√§t ge√§ndert werden, damit die Roundtripf√§higkeit der Zeichen in der gesamten Normalisierungsphase des XML-Parsers erhalten bleibt. Allerdings m√ºssen einige Zeichen so in Entit√§ten ge√§ndert werden, dass das Dokument wohlgeformt ist und somit analysiert werden kann. Im Folgenden sind die bei der Serialisierung geltenden Regeln f√ºr das √Ñndern in Entit√§ten aufgef√ºhrt:  
  
-   Die Zeichen ‚Äû&‚Äú, ‚Äû\<‚Äú, und ‚Äû>‚Äú werden immer in Entit√§ten ge√§ndert &amp;, &lt;, und &gt; bzw. wenn sie in einem Attribut oder Elementinhalt auftreten.  
  
-   Da SQL Server ein Anf√ºhrungszeichen (U+0022) zum Einschlie√üen von Attributwerten verwendet, wird das Anf√ºhrungszeichen in Attributwerten bei der √Ñnderung in Entit√§ten zu &quot;.  
  
-   Ein Ersatzpaar wird beim √Ñndern in Entit√§ten zu einem einzelnen numerischen Zeichenverweis, wenn die Umwandlung nur auf dem Server erfolgt. So wird z.B. das Ersatzpaar U+D800 U+DF00 beim √Ñndern in Entit√§ten zum numerischen Zeichenverweis &\#x00010300;.  
  
-   Um zu verhindern, dass ein Tabstopp (U+0009) und ein Zeilenvorschub (LF, U+000A) beim Analysieren normalisiert werden, werden sie beim √Ñndern in Entit√§ten zu ihren numerischen Zeichenverweisen &\#x9; bzw. &\#xA; innerhalb von Attributwerten.  
  
-   Um zu verhindern, dass ein Wagenr√ºcklauf (CR, U+000D) beim Analysieren normalisiert wird, wird er beim √Ñndern in Entit√§ten zu seinem numerischen Zeichenverweis &\#xD; sowohl innerhalb von Attributwerten als auch in Elementinhalt.  
  
-   Um Textknoten zu sch√ºtzen, die ausschlie√ülich Leerzeichen enthalten, wird eines der Leerzeichen ‚Äì zumeist das letzte ‚Äì beim √Ñndern in Entit√§ten zu dessen numerischem Zeichenverweis. Auf diese Weise bleibt der Leerzeichentextknoten beim Neuanalysieren erhalten, und zwar unabh√§ngig von der Einstellung zur Handhabung von Leerzeichen beim Analysieren.  
  
 Zum Beispiel:  
  
```sql
declare @u NVARCHAR(50)  
set @u = N'<a a="  
    '+NCHAR(0xD800)+NCHAR(0xDF00)+N'>">   '+NCHAR(0xA)+N'</a>'  
select CAST(CONVERT(XML,@u,1) as NVARCHAR(50))  
```  
  
 Dies ist das Ergebnis:  
  
```  
<a a="  
    êåÄ>">     
</a>  
```  
  
 Wenn Sie die letzte Leerzeichenschutzregel nicht anwenden wollen, k√∂nnen Sie die explizite CONVERT-Option 1 beim Umwandeln von **xml** in einen Zeichenfolgen- oder Bin√§rtyp verwenden. Sie k√∂nnen z. B. folgende Aktionen ausf√ºhren, um das √Ñndern in Entit√§ten zu vermeiden:  
  
```sql
select CONVERT(NVARCHAR(50), CONVERT(XML, '<a>   </a>', 1), 1)  
```  
  
 Beachten Sie, dass die [query()-Methode (xml-Datentyp)](/sql/t-sql/xml/query-method-xml-data-type) eine xml-Datentypinstanz ergibt. Deshalb wird jedes Ergebnis der **query()** -Methode, das in einen Zeichenfolgen- oder Bin√§rtyp umgewandelt wird, entsprechend den zuvor beschriebenen Regeln in Entit√§ten ge√§ndert. Wenn Sie Zeichenfolgenwerte erhalten wollen, die nicht in Entit√§ten ge√§ndert wurden, sollten Sie stattdessen die [value()-Methode (xml-Datentyp)](/sql/t-sql/xml/value-method-xml-data-type) verwenden. Es folgt ein Beispiel zum Verwenden der **query()** -Methode:  
  
```sql
declare @x xml  
set @x = N'<a>This example contains an entitized char: <.</a>'  
select @x.query('/a/text()')  
```  
  
 Dies ist das Ergebnis:  
  
```  
This example contains an entitized char: <.  
```  
  
 Es folgt ein Beispiel zum Verwenden der **query(** )-Methode:  
  
```sql
select @x.value('(/a/text())[1]', 'nvarchar(100)')  
```  
  
 Dies ist das Ergebnis:  
  
```  
This example contains an entitized char: <.  
```  
  
## <a name="serializing-a-typed-xml-data-type"></a>Serialisieren eines typisierten xml-Datentyps  
 Eine typisierte **xml** -Datentypinstanz enth√§lt Werte, die entsprechend ihren XML-Schematypen typisiert sind. Diese Werte werden entsprechend ihrem XML-Schematyp in dasselbe Format serialisiert, wie es bei der XQuery-Umwandlung in xs:string entsteht. Weitere Informationen finden Sie unter [Typumwandlungsregeln in XQuery](/sql/xquery/type-casting-rules-in-xquery).  
  
 So wird z. B. der xs:double-Wert 1.34e1 zu 13.4 serialisiert, wie das im folgenden Beispiel gezeigt wird.  
  
```sql
declare @x xml  
set @x =''  
select CAST(@x.query('1.34e1') as nvarchar(50))  
```  
  
 Es wird der Zeichenfolgenwert 13.4 zur√ºckgegeben.  
  
## <a name="see-also"></a>Siehe auch  
 [Typumwandlungsregeln in XQuery](/sql/xquery/type-casting-rules-in-xquery)   
 [CAST und CONVERT &#40;Transact-SQL&#41;](/sql/t-sql/functions/cast-and-convert-transact-sql)  
  
  
