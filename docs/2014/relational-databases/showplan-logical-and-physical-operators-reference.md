---
title: Referenz zu logischen und physischen Showplanoperatoren | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: e4e45de57f4ea1ea88b72df7190e5ec8c3a1f768
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "62627328"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referenz zu logischen und physischen Showplanoperatoren
  Operatoren beschreiben, wie eine Abfrage oder eine DML-Anweisung (Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ausgeführt wird. Der Abfrageoptimierer verwendet Operatoren, um einen Abfrageplan für das in der Abfrage angegebene Ergebnis zu erstellen, oder zum Ausführen des in der DML-Anweisung angegebenen Vorgangs. Der Abfrageplan ist eine Struktur, die aus physischen Operatoren besteht. Sie können den Abfrageplan mit den SET SHOWPLAN-Anweisungen, den grafischen Ausführungsplanoptionen in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], oder den SQL Server Profiler Showplan-Ereignisklassen anzeigen.  
  
 Operatoren werden als logische und physische Operatoren klassifiziert.  
  
 **Logische Operatoren**  
 Logische Operatoren beschreiben den relationalen algebraischen Vorgang, der für die Anweisungsverarbeitung verwendet wird. Mit anderen Worten, logische Operatoren beschreiben konzeptionell den auszuführenden Vorgang.  
  
 **Physische Operatoren**  
 Physische Operatoren implementieren den durch logische Operatoren beschriebenen Vorgang. Jeder physische Operator ist ein Objekt oder eine Routine, das bzw. die einen Vorgang ausführt. Einige Operatoren greifen z. B. auf Spalten oder Zeilen einer Tabelle, eines Index oder einer Sicht zu. Andere physische Operatoren führen andere Vorgänge aus, z. B. Berechnungen, Aggregationen, Datenintegritätsprüfungen oder Joins. Physischen Operatoren sind Kosten zugeordnet.  
  
 Über die physischen Operatoren werden Daten initialisiert, aufgelistet und beendet. Der physische Operator kann insbesondere die folgenden drei Methodenaufrufe beantworten:  
  
-   **Init():** Mit der Methode **Init()** wird ein physischer Operator initialisiert und dazu angewiesen, erforderliche Datenstrukturen einzurichten. Der physische Operator kann mehrere **Init()** -Aufrufe empfangen; in der Regel empfängt er jedoch nur einen.  
  
-   **GetNext():** Mit der Methode **GetNext()** wird ein Operator angewiesen, die erste oder nächste Datenzeile abzurufen. Der physische Operator kann null oder mehrere **GetNext()** -Aufrufe empfangen.  
  
-   **Close():** Mit der Methode **Close()** wird der physische Operator dazu angewiesen, einige Cleanupvorgänge auszuführen und sich selbst zu beenden. Ein physischer Operator empfängt nur einen **Close()** -Aufruf.  
  
 Die **GetNext()**-Methode gibt eine Datenzeile zurück, und die Anzahl der Aufrufe wird als **ActualRows** in der durch SET STATISTICS PROFILE ON oder SET STATISTICS XML ON erstellten Showplanausgabe angezeigt. Weitere Informationen zu diesen SET-Optionen finden Sie unter [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) und [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Die **ActualRebinds**- und **ActualRewinds**-Zähler, die in der Showplanausgabe angezeigt werden, beziehen sich auf die Anzahl der Aufrufe der **Init()**-Methode. **ActualRebinds** entspricht 1 und **ActualRewinds** entspricht 0, es sei denn, ein Operator befindet sich innerhalb eines Schleifenjoins. Wenn sich ein Operator innerhalb eines Schleifenjoins befindet, muss die Summe der erneuten Bindungen und Zurückspulvorgänge der Anzahl der verarbeiteten Vorgänge außerhalb des Joins entsprechen. Unter 'erneuter Bindung' wird verstanden, dass sich mindestens ein korrelierter Parameter des Joins geändert hat und daher das Innere des Joins neu ausgewertet werden muss. Unter 'Zurückspulvorgang' wird verstanden, dass sich keiner der korrelierten Parameter geändert hat und das vorherige innere Resultset daher wiederverwendet werden kann.  
  
 **ActualRebinds** und **ActualRewinds** sind in der mithilfe von SET STATISTICS XML ON erstellten XML-Showplanausgabe vorhanden. Sie werden nur aufgefüllt, für die **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, und  **Funktion mit Tabellenrückgabe** Operatoren. **ActualRebinds** und **ActualRewinds** auch eingetragen werden für die `Assert` und **Filter** Operatoren bei der **StartupExpression** Attribut wird auf "true" festgelegt.  
  
 Wenn **ActualRebinds** und **ActualRewinds** in einem XML-Showplan vorhanden sind, können sie mit **EstimateRebinds** und **EstimateRewinds**verglichen werden. Wenn sie nicht vorhanden sind, kann die geschätzte Zeilenanzahl (**EstimateRows**) mit der tatsächlichen Zeilenanzahl (**ActualRows**) verglichen werden. Beachten Sie, dass die tatsächliche grafische Showplanausgabe für tatsächliche erneute Bindungen und Zurückspulvorgänge Nullen anzeigt, wenn letztere nicht vorhanden sind.  
  
 Ein entsprechender Zähler, **ActualEndOfScans**, ist verfügbar, wenn die Showplanausgabe mithilfe von SET STATISTICS XML ON erstellt wird. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wie bei erneuten Bindungen und Zurückspulvorgängen kann die Anzahl für das Scanende größer als 1 sein; aber nur, wenn sich der Operator innerhalb eines Schleifenjoins befindet. Die Anzahl für Scanende muss kleiner oder gleich der Summe der erneuten Bindungen und Zurückspulvorgänge sein.  
  
## <a name="mapping-physical-and-logical-operators"></a>Zuordnen von physischen und logischen Operatoren  
 Der Abfrageoptimierer erstellt einen Abfrageplan als Struktur, die aus logischen Operatoren besteht. Nach dem Erstellen des Abfrageplans wählt der Abfrageoptimierer für jeden logischen Operator den effizientesten physischen Operator aus. Der Abfrageoptimierer entscheidet auf Basis der Kosten, welcher physischer Operator einen logischen Operator implementieren soll.  
  
 Normalerweise kann ein logischer Vorgang von mehreren physischen Operatoren implementiert werden. Ein physischer Operator kann jedoch in seltenen Fällen mehrere logische Vorgänge implementieren.  
  
## <a name="operator-descriptions"></a>Beschreibung der Operatoren  
 In diesem Abschnitt finden Sie Beschreibungen der logischen und physischen Operatoren.  
  
|Symbol für grafischen Ausführungsplan|Showplanoperator|Description|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|Mit dem `Aggregate`-Operator wird ein Ausdruck berechnet, der MIN, MAX, SUM, COUNT oder AVG enthält. Der `Aggregate`-Operator kann ein logischer oder physischer Operator sein.|  
|![Operatorsymbol für arithmetische Ausdrücke (Symbol)](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Operatorsymbol für arithmetische Ausdrücke (Symbol)")|`Arithmetic Expression`|Der `Arithmetic Expression`-Operator berechnet einen neuen Wert anhand vorhandener Werte in einer Zeile. `Arithmetic Expression` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.|  
|![Assert-Operator (Symbol)](../../2014/database-engine/media/assert-32x.gif "Assert-Operator (Symbol)")|`Assert`|Der `Assert`-Operator überprüft eine Bedingung. Beispielsweise überprüft er die referenzielle Integrität, oder er stellt sicher, dass eine skalare Unterabfrage eine Zeile zurückgibt. Für jede Eingabezeile die `Assert` -Operator wertet den Ausdruck in der `Argument` -Spalte des Ausführungsplans. Wird der Ausdruck mit NULL ausgewertet, so wird die Zeile an den `Assert`-Operator übergeben, und die Ausführung der Abfrage wird fortgesetzt. Wird dieser Ausdruck zu einem Nicht-NULL-Wert ausgewertet, so wird der entsprechende Fehler ausgelöst. Der `Assert`-Operator ist ein physischer Operator.|  
|![Assign-Sprachelement (Symbol)](../../2014/database-engine/media/assign-32.gif "Assign-Sprachelement (Symbol)")|`Assign`|Der `Assign`-Operator weist einer Variablen den Wert eines Ausdrucks oder einer Konstanten zu. `Assign` ist ein Sprachelement.|  
|None|`Asnyc Concat`|Der `Asnyc Concat`-Operator wird nur in Remoteabfragen (verteilten Abfragen) verwendet. Diese Anweisung weist *n* untergeordnete Knoten und einen übergeordneten Knoten auf. Gewöhnlich sind manche untergeordnete Knoten Remotecomputer, die an einer verteilten Abfrage beteiligt sind. `Asnyc Concat` gibt `open()`-Aufrufe für alle untergeordneten Knoten gleichzeitig aus und wendet dann auf jeden untergeordneten Knoten eine Bitmap an. Für jedes Bit, das 1 ist, sendet `Async Concat` auf Anfrage die Ausgabezeilen an den übergeordneten Knoten.|  
|![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operator (Symbol)")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] verwendet die `Bitmap` Operator, um in parallelen Abfrageplänen Filtern mithilfe einer Bitmap zu implementieren. Abfrageausführung beschleunigt, indem Zeilen mit Schlüsselwerten, die keine joindatensätze erstellen darf nicht vor der Übergabe von Zeilen durch einen anderen Operator wie z. B. eliminiert Filtern mithilfe einer Bitmap die `Parallelism` Operator. Ein Bitmapfilter verwendet eine kompakte Darstellung einer Gruppe von Werten aus einer Tabelle in einem Bereich der Operatorstruktur, um Zeilen aus einer zweiten Tabelle in einem anderen Bereich der Struktur zu filtern. Durch das Entfernen unnötiger Zeilen zu einem frühen Zeitpunkt in der Abfrage müssen nachfolgende Operatoren weniger Zeilen verarbeiten, wodurch eine Steigerung der Gesamtleistung der Abfrage erzielt werden kann. Der Optimierer bestimmt, wann eine Bitmap eine ausreichende Selektivität aufweist, damit sie verwendet werden kann, und in welchen Operatoren der Filter angewendet wird. `Bitmap` ist ein physischer Operator.|  
|![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operator (Symbol)")|`Bitmap Create`|Der `Bitmap Create`-Operator wird in der Showplanausgabe dort angezeigt, wo Bitmaps erstellt werden. `Bitmap Create` ist ein logischer Operator.|  
|![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|`Bookmark Lookup`|Der `Bookmark Lookup`-Operator verwendet ein Lesezeichen (Zeilen-ID oder Gruppierungsschlüssel), um die zugehörige Zeile in der Tabelle oder im gruppierten Index nachzuschlagen. Die `Argument` Spalte enthält die lesezeichenbeschriftung, um die Zeile in der Tabellen- oder gruppierten Index nachzuschlagen. Die `Argument` -Spalte enthält auch den Namen der Tabelle oder des gruppierten Indexes in der die Zeile nachgeschlagen wird. Wenn die WITH PREFETCH-Klausel wird, in angezeigt der `Argument` Spalte, dass es am besten mit asynchronem Vorauslesen (Read-ahead) nachgeschlagen Lesezeichen in der Tabelle oder einen gruppierten Index handelt, hat der Abfrageprozessor ermittelt.<br /><br /> `Bookmark Lookup` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet. `Clustered Index Seek` und `RID Lookup` stellen hingegen Suchfunktionen für Lesezeichen bereit. Auch der `Key Lookup`-Operator stellt diese Funktionalität bereit.|  
|None|`Branch Repartition`|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt. Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt. `Branch Repartition` und `Segment Repartition` sind logische Operatoren.|  
|None|`Broadcast`|`Broadcast` weist einen untergeordneten Knoten und *n* übergeordnete Knoten. `Broadcast` sendet die Eingabezeilen bei Bedarf an mehrere Consumer. Jeder Consumer erhält alle Zeilen. Wenn z.B. alle Consumer sich auf der Erstellungsseite eines Hashjoins befinden, werden *n* Kopien der Hashtabellen erstellt.|  
|![Build Hash-Operator (Symbol)](../../2014/database-engine/media/build-hash.gif "Build Hash-Operator (Symbol)")|`Build Hash`|Gibt die Erstellung einer Batchhashtabelle für einen speicheroptimierten xVelocity-columnstore-Index an.|  
|None|`Cache`|`Cache` ist eine spezielle Version des der **Spool** Operator. Er speichert nur eine Datenzeile. `Cache` ist ein logischer Operator. `Cache` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.|  
|![Clustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete-Operator (Symbol)")|`Clustered Index Delete`|Der `Clustered Index Delete`-Operator löscht Zeilen aus dem gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn Sie eine WHERE-:() Prädikat in der Argument-Spalte, klicken Sie dann nur die Zeilen vorhanden ist, die gelöscht, werden des Prädikats erfüllen.`Clustered Index Delete` ist ein physischer Operator.|  
|![Clustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert-Operator (Symbol)")|`Clustered Index Insert`|Der `Clustered Index Insert`-Showplanoperator fügt die Eingabezeilen in den gruppierten Index ein, der in der Argument-Spalte angegeben ist. Die Argument-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. Wenn `Clustered Index Insert` hat keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus der `Insert` Operator selbst.`Clustered Index Insert` ist ein physischer Operator.|  
|![Clustered Index Merge-Operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Merge-Operator")|**Clustered Index Merge**|Der **Clustered Index Merge** -Operator übernimmt einen Mergedatenstrom für einen gruppierten Index. Der Operator löscht, aktualisieren oder Einfügen von Zeilen aus dem gruppierten Index im angegebenen die `Argument` -Spalte des Operators. Der tatsächliche ausgeführte Vorgang hängt von der Common Language Runtime-Wert, der die **Aktion** in angegebene Spalte den `Argument` -Spalte des Operators. **Clustered Index Merge** ist ein physischer Operator.|  
|![Clustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Scan-Operator (Symbol)")|`Clustered Index Scan`|Der `Clustered Index Scan`-Operator scannt den gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn ein optionales WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. Wenn die Argument-Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor angefordert, dass die Ausgabe der Zeilen in der Reihenfolge zurückgegeben wird, in der sie vom gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, scannt die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). `Clustered Index Scan` ist ein logischer und physischer Operator.|  
|![Clustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek-Operator (Symbol)")|`Clustered Index Seek`|Der `Clustered Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem gruppierten Index abzurufen. Die `Argument` Spalte enthält den Namen des verwendeten gruppierten Indexes und die Verschiebung :() Prädikat. Die Speicher-Engine verarbeitet mit diesem Index nur die Zeilen, die das SEEK:()-Prädikat erfüllen. Es kann auch ein WHERE:()-Prädikat einschließen, das die Speicher-Engine für alle Zeilen auswertet, die das SEEK:()-Prädikat erfüllen. Dies ist jedoch optional, und es werden keine Indizes für diesen Prozess verwendet.<br /><br /> Wenn die `Argument` Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in dem gruppierte Index wurden sortiert. Wurde die ORDERED-Klausel nicht angegeben, durchsucht die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. Bei der Anzeige des LOOKUP-Schlüsselworts, wird ein Bookmark Lookup ausgeführt. In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] und höheren Versionen wird die `Key Lookup` -Operator stellt die Bookmark Lookup-Funktionalität bereit. `Clustered Index Seek` ist ein logischer und physischer Operator.|  
|![Clustered Index Update-Operator (Symbol)](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Update-Operator (Symbol)")|`Clustered Index Update`|Die `Clustered Index Update` -Operator aktualisiert Eingabezeilen in dem gruppierten Index angegeben wird, der `Argument` Spalte. Wenn :() eine WHERE-Prädikat vorhanden ist, werden nur die Zeilen, die dieses Prädikat werden aktualisiert, zu erfüllen. Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. Wenn ein DEFINE:()-Prädikat vorhanden ist, werden die durch diesen Operator definierten Werte aufgelistet. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie in dieser Abfrage verwiesen werden. `Clustered Index Update` ist ein logischer und physischer Operator.|  
|![Collapse-Operator (Symbol)](../../2014/database-engine/media/collapse-32x.gif "Collapse-Operator (Symbol)")|`Collapse`|Der `Collapse`-Operator optimiert die Verarbeitung von Aktualisierungen. Eine Aktualisierung kann bei ihrer Ausführung mithilfe des `Split`-Operators in einen Lösch- und einen Einfügevorgang aufgeteilt werden. Die `Argument` Spalte enthält eine Gruppe :()-Klausel, die eine Liste von Schlüsselspalten angibt. Wenn der Abfrageprozessor benachbarte Zeilen erkennt, die dieselben Schlüsselwerte löschen und einfügen, werden diese separaten Vorgänge durch einen einzigen effektiveren Updatevorgang ersetzt. `Collapse` ist ein logischer und physischer Operator.|  
|![Columnstore-Indexscan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore-Indexscan")|`Columnstore Index Scan`|Die `Columnstore Index Scan` -Operator scannt den columnstore-Index im angegebenen die `Argument` Spalte des Abfrageausführungsplans.|  
|![Compute Scalar-Operator (Symbol)](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar-Operator (Symbol)")|`Compute Scalar`|Die `Compute Scalar` -Operator wertet einen Ausdruck ein, um einen berechneten skalaren Wert zu erzeugen. Dieser kann an den Benutzer zurückgegeben und/oder an anderer Stelle in der Abfrage als Verweis verwendet werden. Ein Beispiel für beide Fälle ist ein Filterprädikat oder Joinprädikat. `Compute Scalar` ist ein logischer und physischer Operator.<br /><br /> `Compute Scalar` Operatoren, die in den von SET STATISTICS XML generierten Showplans angezeigt werden, enthalten eventuell nicht die `RunTimeInformation` Element. In grafischen Showplans können **Tatsächliche Zeilen**, **Tatsächlich erneuerte Bindungen**und **Tatsächliche Zurückspulvorgänge** im Fenster **Eigenschaften** fehlen, wenn die Option **Tatsächlichen Ausführungsplan einschließen** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]aktiviert wurde. Wenn diese Situation eintritt, bedeutet das, dass diese Operatoren zwar im kompilierten Abfrageplan verwendet wurden, ihre Arbeit jedoch von anderen Operatoren im Laufzeitabfrageplan verrichtet wurde. Beachten Sie außerdem, dass die Anzahl der Ausführungen in der von SET STATISTICS PROFILE generierten Showplanausgabe gleich der Summe der erneuten Bindungen und Zurückspulvorgänge in den von SET STATISTICS XML generierten Showplans ist.|  
|![Concatenation-Operator (Symbol)](../../2014/database-engine/media/concatenation-32x.gif "Concatenation-Operator (Symbol)")|**Concatenation**|Der **Concatenation** -Operator scannt mehrere Eingaben und gibt die gescannten Zeilen zurück. **Concatenation** wird im Allgemeinen verwendet, um das [!INCLUDE[tsql](../includes/tsql-md.md)] -Konstrukt UNION ALL zu implementieren. Der physische Operator **Concatenation** verfügt über mindestens zwei Eingaben und eine Ausgabe. Concatenation kopiert Zeilen aus dem ersten Eingabedatenstrom in den Ausgabedatenstrom und wiederholt diese Operation anschließend für jeden weiteren Eingabedatenstrom. **Concatenation** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Constant Scan-Operator (Symbol)](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan-Operator (Symbol)")|`Constant Scan`|Die `Constant Scan` -Operators wird mindestens eine Konstante Zeile in eine Abfrage eingeführt. Ein `Compute Scalar` -Operator wird häufig verwendet, nach einem `Constant Scan` , um eine Zeile mit dem erzeugten Spalten hinzuzufügen der `Constant Scan` Operator.|  
|![Convert-Sprachelement (Datenbank-Engine - Symbol)](../../2014/database-engine/media/convert-32x.gif "Convert-Sprachelement (Datenbank-Engine - Symbol)")|`Convert`|Der `Convert`-Operator wandelt einen skalaren Datentyp in einen anderen um. `Convert` ist ein Sprachelement.|  
|None|`Cross Join`|Der `Cross Join`-Operator verknüpft jede Zeile der ersten (oberen) Eingabe mit jeder Zeile der zweiten (unteren) Eingabe. `Cross Join` ist ein logischer Operator.|  
|![Cursorsammelelement (Cursoroperatorsymbol)](../../2014/database-engine/media/cursor-catch-all.gif "Cursorsammelelement (Cursoroperatorsymbol)")|`catchall`|Das Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachelemente).|  
|None|**Cursor**|Die logischen und physischen **Cursor** -Operatoren beschreiben, wie eine Abfrage oder Aktualisierung mit Cursoroperationen ausgeführt wird. Die physischen Operatoren beschreiben den Algorithmus, der für die physische Implementierung der Cursorverarbeitung verwendet wird, wie z. B. Verwenden eines keysetgesteuerten Cursors. Jeder Schritt bei der Ausführung eines Cursors benötigt einen physischen Operator. Die logischen Operatoren beschreiben eine Cursoreigenschaft, z. B. der Cursor ist schreibgeschützt.<br /><br /> Zu den logischen Operatoren zählen Asynchronous, Optimistic, Primary, Read Only, Scroll Locks sowie Secondary und Synchronous.<br /><br /> Zu den physischen Operatoren zählen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query und Snapshot.|  
|![Declare-Sprachelement (Symbol)](../../2014/database-engine/media/declare-32x.gif "Declare-Sprachelement (Symbol)")|`Declare`|Die `Declare` -Operator weist eine lokale Variable im Abfrageplan. `Declare` ist ein Sprachelement.|  
|![Delete-Operator (Datenbank-Engine – Symbol)](../../2014/database-engine/media/delete-32x.gif "Delete-Operator (Datenbank-Engine – Symbol)")|`Delete`|Die `Delete` -Operator löscht aus einem Objekt alle Zeilen, die das optionale Prädikat in erfüllen die `Argument` Spalte.|  
|![Delete Scan-Operator (Symbol)](../../2014/database-engine/media/delete-scan-32x.gif "Delete Scan-Operator (Symbol)")|`Deleted Scan`|Der `Deleted Scan`-Operator scannt die deleted-Tabelle in einem Trigger.|  
|None|`Distinct`|Mithilfe des `Distinct`-Operators werden Duplikate aus einem Rowset oder aus einer Sammlung von Werten entfernt. `Distinct` ist ein logischer Operator.|  
|None|`Distinct Sort`|Die `Distinct Sort` logische Operator scannt die Eingabe und entfernt Duplikate und sortiert nach den Spalten in der :() Prädikat von DISTINCT ORDER BY angegeben die `Argument` Spalte. `Distinct Sort` ist ein logischer Operator.|  
|![Distribute Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute Streams Parallelism-Operator (Symbol)")|**Distribute Streams**|Der **Distribute Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Distribute Streams** -Operator nimmt genau einen Eingabedatenstrom von Datensätzen an und erzeugt mehrere Ausgabedatenströme. Inhalt und Format der Datensätze werden nicht geändert. Jeder Datensatz aus dem Eingabedatenstrom wird in genau einem der Ausgabedatenströme angezeigt. Dieser Operator behält die relative Reihenfolge der Eingabedatensätze in den Ausgabedatenströmen bei. In der Regel wird mit einem Hashingverfahren festgelegt, zu welchem Ausgabedatenstrom ein bestimmter Eingabedatensatz gehört.<br /><br /> Wenn die Ausgabe partitioniert ist, und klicken Sie dann die `Argument` Spalte enthält einen PARTITIONSSPALTEN :() Prädikat und die Partitionierungsspalten. **Distribute Streams** ist ein logischer Operator.|  
|![Dynamic-Cursoroperator (Symbol)](../../2014/database-engine/media/dynamic-32x.gif "Dynamic-Cursoroperator (Symbol)")|`Dynamic`|Der `Dynamic`-Operator verwendet einen Cursor, der alle von anderen vorgenommenen Änderungen wahrnimmt.|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Eager Spool**|Die **Eager Spool** -Operator benötigt die gesamte Eingabe und speichert jede Zeile in einem verborgenen temporären Objekt der `tempdb` Datenbank. Wenn der Operator zurückgesetzt wird (z. B. durch eine `Nested Loops` Operator) aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Eager Spool** -Operator erstellt seine Spooldatei unverzüglich: Wenn der übergeordnete Operator des Spoolvorgangs die erste Zeile anfordert, verarbeitet der Spool-Operator alle Zeilen aus dem Eingabeoperator und speichert sie im Spool. **Eager Spool** ist ein logischer Operator.|  
|![Fetch Query-Cursoroperator (Symbol)](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query-Cursoroperator (Symbol)")|`Fetch Query`|Der `Fetch Query`-Operator ruft Zeilen ab, wenn eine Abrufoperation für einen Cursor ausgegeben wird.|  
|![Filter-Operator (Datenbank-Engine - Symbol)](../../2014/database-engine/media/filter-32x.gif "Filter-Operator (Datenbank-Engine - Symbol)")|**Filter**|Die **Filter** -Operator scannt die Eingabe und gibt nur die Zeilen, die den Filterausdruck (Prädikat), die erfüllen in angezeigt wird. die `Argument` Spalte.|  
|None|`Flow Distinct`|Der logische Operator `Flow Distinct` scannt die Eingabe und entfernt Duplikate. Während der `Distinct` -Operator zuerst die gesamte Eingabe vor der Ausgabe erstellt, verarbeitet die **FlowDistinct** -Operator gibt jede Zeile zurück, wie sie aus der Eingabe abgerufen wird (es sei denn, diese Zeile ein Duplikat ist, in diesem Fall wird Sie verworfen).|  
|None|`Full Outer Join`|Der logische `Full Outer Join`-Operator gibt alle Zeilen zurück, die das JOIN-Prädikat aus der ersten (oberen) Eingabe, verknüpft mit jeder Zeile aus der zweiten (unteren) Eingabe, erfüllen. Er gibt außerdem die folgenden Zeilen zurück:<br /><br /> – Zeilen aus der ersten Eingabe, für die in der zweiten Eingabe keine Übereinstimmung besteht.<br /><br /> – Zeilen aus der zweiten Eingabe, für die in der ersten Eingabe keine Übereinstimmung besteht.<br /><br /> <br /><br /> Eingaben, die keine übereinstimmenden Werte enthalten, werden als NULL-Wert zurückgegeben. `Full Outer Join` ist ein logischer Operator.|  
|![Gather Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-32x.gif "Gather Streams Parallelism-Operator (Symbol)")|**Gather Streams**|Der **Gather Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Gather Streams** -Operator verarbeitet mehrere Eingabedatenströme, fasst diese zusammen und erzeugt genau einen Ausgabedatenstrom von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen. Wenn die Ausgabe sortiert ist, die `Argument` Spalte enthält eine ORDER BY :() Prädikat und die Namen der zu sortierenden Spalten. **Gather Streams** ist ein logischer Operator.|  
|![Hash Match-Operator (Symbol)](../../2014/database-engine/media/hash-match-32x.gif "Hash Match-Operator (Symbol)")|`Hash Match`|Der `Hash Match`-Operator erzeugt eine Hashtabelle, indem er für jede Zeile der Erstellungseingabe einen Hashwert berechnet. Ein HASH mit einer Liste von Spalten, die zum Erstellen der Hashwerte :() Prädikat wird in der `Argument` Spalte. Anschließend wird, soweit möglich, für jede Einfügezeile ein Hashwert (mithilfe derselben Hashfunktion) berechnet und in der Hashtabelle nach Übereinstimmungen gesucht. Wenn ein residual-Prädikat vorhanden ist (identifiziert durch RESIDUAL :() in der `Argument` Spalte), dieses Prädikat auch für Zeilen, um als übereinstimmend angesehen werden eingehalten werden muss. Das Verhalten des Operators hängt von dem auszuführenden logischen Vorgang ab:<br /><br /> Für jeden Join wird die erste (obere) Eingabe verwendet, um die Hashtabelle zu erstellen, und die zweite (untere) Eingabe zum Einfügen in die Hashtabelle. Die Ausgabeübereinstimmungen (oder Nichtübereinstimmungen) werden vom Jointyp bestimmt. Wenn mehrere Joins dieselbe Joinspalte verwenden, werden diese Vorgänge in einem Hashteam gruppiert.<br /><br /> Für die Operatoren Distinct oder Aggregate wird die Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt und Aggregatausdrücke berechnet werden). Wenn die Hashtabelle erstellt ist, wird die Tabelle gescannt, und alle Einträge werden ausgegeben.<br /><br /> Für den Union-Operator wird die erste Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt werden). Die zweite Eingabe (die keine Duplikate haben darf) wird zum Einfügen in die Hashtabelle verwendet, wobei alle nicht übereinstimmenden Zeilen zurückgegeben werden, anschließend wird die Hashtabelle gescannt, und alle Einträge werden zurückgegeben.<br /><br /> <br /><br /> `Hash Match` ist ein physischer Operator.|  
|![If-Sprachelement (Symbol)](../../2014/database-engine/media/if-32x.gif "If-Sprachelement (Symbol)")|`If`|Der `If`-Operator führt eine bedingte Verarbeitung basierend auf einem Ausdruck aus. `If` ist ein Sprachelement.|  
|None|`Inner Join`|Der logische `Inner Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen.|  
|![Insert (Datenbank-Engine - Operatorsymbol)](../../2014/database-engine/media/insert-32x.gif "Insert (Datenbank-Engine - Operatorsymbol)")|`Insert`|Die `Insert` logischer Operator fügt alle Eingabezeilen in dem im angegebenen Objekt der `Argument` Spalte. Der physische Operator ist entweder der Operator `Table Insert`, `Index Insert` oder `Clustered Index Insert`.|  
|![Inserted Scan-Operator (Symbol)](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted Scan-Operator (Symbol)")|**Inserted Scan**|Der **Inserted Scan** -Operator scannt die **inserted** -Tabelle. **Inserted Scan** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Intrinsic-Sprachelement (Symbol)](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic-Sprachelement (Symbol)")|`Intrinsic`|Der `Intrinsic`-Operator ruft eine interne [!INCLUDE[tsql](../includes/tsql-md.md)]-Funktion auf. `Intrinsic` ist ein Sprachelement.|  
|![Iteratorsammelelement (Operatorsymbol)](../../2014/database-engine/media/iterator-catch-all.gif "Iteratorsammelelement (Operatorsymbol)")|`Iterator`|Das `Iterator`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|`Key Lookup`|Die `Key Lookup` Operator stellt eine Lesezeichensuche für eine Tabelle mit einem gruppierten Index. Die `Argument` Spalte enthält den Namen des gruppierten Indexes und den Gruppierungsschlüssel verwendet, um die Zeile im gruppierten Index nachzuschlagen. `Key Lookup` wird immer zusammen mit einem `Nested Loops` Operator. Wenn die WITH PREFETCH-Klausel wird, in angezeigt der `Argument` Spalte, dass es am besten mit asynchronem Vorauslesen (Read-ahead) nachgeschlagen Lesezeichen im gruppierten Index handelt, hat der Abfrageprozessor ermittelt.<br /><br /> Die Verwendung von einem `Key Lookup` Operator im Abfrageplan gibt an, dass die Abfrage von leistungsoptimierung profitieren könnten. Beispielsweise kann die Leistung durch Hinzufügen eines abdeckenden Indexes optimiert werden.|  
|![Keyset-Cursoroperator (Symbol)](../../2014/database-engine/media/keyset-32x.gif "Keyset-Cursoroperator (Symbol)")|`Keyset`|Der `Keyset`-Operator verwendet einen Cursor, für den Aktualisierungen, jedoch keine von anderen vorgenommenen Einfügungen, sichtbar sind.|  
|![Sprachsammelelement (Symbol)](../../2014/database-engine/media/language-construct-catch-all.gif "Sprachsammelelement (Symbol)")|`Language Element`|Das `Language Element`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Lazy Spool**|Die **Lazy Spool** logischer Operator speichert alle Zeilen aus der Eingabe in einem verborgenen temporären Objekt der `tempdb` Datenbank. Wenn der Operator zurückgesetzt wird (z. B. durch eine `Nested Loops` Operator) aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Lazy Spool** -Operator erstellt seine Spooldatei mit Verzögerung. Das bedeutet, dass der Spooloperator jedes Mal, wenn der übergeordnete Operator des Spoolvorgangs eine Zeile anfordert, eine Zeile aus seinem Eingabeoperator erhält und sie im Spool speichert, anstatt alle Zeilen gleichzeitig zu verarbeiten. Lazy Spool ist ein logischer Operator.|  
|None|`Left Anti Semi Join`|Der `Left Anti Semi Join`-Operator gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein joinprädikat in vorhanden ist. die `Argument` Spalte, die jede Zeile eine übereinstimmende Zeile ist. `Left Anti Semi Join` ist ein logischer Operator.|  
|None|`Left Outer Join`|Der `Left Outer Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen. Er gibt auch alle Zeilen aus der ersten Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten Eingabe vorhanden ist. Die nicht übereinstimmenden Zeilen in der zweiten Eingabe werden als NULL-Werte zurückgegeben. Wenn kein joinprädikat in vorhanden ist. die `Argument` Spalte, die jede Zeile eine übereinstimmende Zeile ist. `Left Outer Join` ist ein logischer Operator.|  
|None|`Left Semi Join`|Der Operator `Left Semi Join` gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die eine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein joinprädikat in vorhanden ist. die `Argument` Spalte, die jede Zeile eine übereinstimmende Zeile ist. `Left Semi Join` ist ein logischer Operator.|  
|![Log Row Scan-Operator (Symbol)](../../2014/database-engine/media/log-row-scan-32x.gif "Log Row Scan-Operator (Symbol)")|`Log Row Scan`|Der `Log Row Scan`-Operator scannt das Transaktionsprotokoll. `Log Row Scan` ist ein logischer und physischer Operator.|  
|![Merge Interval-Operator (Symbol)](../../2014/database-engine/media/merge-interval-32x.gif "Merge Interval-Operator (Symbol)")|`Merge Interval`|Der Operator `Merge Interval` führt mehrere (möglicherweise überlappende) Intervalle zusammen, um minimale, nicht überlappende Intervalle zu erzeugen, die anschließend zum Suchen von Indexeinträgen verwendet werden. Dieser Operator erscheint in der Regel über einem oder mehreren `Compute Scalar` Operatoren `Constant Scan` -Operatoren erscheinen, welche die Intervalle (dargestellt als Spalten in einer Zeile) aufbauen, die von diesem Operator zu mischenden. `Merge Interval` ist ein logischer und physischer Operator.|  
|![Merge Join-Operator (Symbol)](../../2014/database-engine/media/merge-join-32x.gif "Merge Join-Operator (Symbol)")|**Merge Join**|Der **Merge Join** -Operator führt die logischen Vorgänge „innere Verknüpfung“, „linke äußere Verknüpfung“, „linke Semiverknüpfung“, „linke Antisemiverknüpfung“, „rechte äußere Verknüpfung“, „rechte Semiverknüpfung“, „rechte Antisemiverknüpfung“ und „Vereinigung“ aus.<br /><br /> In der `Argument` Spalte, die **Merge Join** -Operator enthält eine Zusammenführung :() Prädikat aus, wenn der Vorgang einen 1: n Join ausführt, oder eine m: N-:() Prädikat, Merge Wenn der Vorgang einen m: n Join ausführt. Die `Argument` -Spalte schließt auch eine durch Trennzeichen getrennte Liste von Spalten, die zum Ausführen des Vorgangs. Der **Merge Join** -Operator benötigt zwei Eingaben, die nach den jeweiligen Spalten sortiert sind, möglicherweise durch Einfügen von expliziten Sortiervorgängen in den Abfrageplan. Ein Zusammenführungsjoin ist vor allem effizient, wenn kein expliziter Sortiervorgang erforderlich ist, beispielsweise wenn ein geeigneter B-Struktur-Index in der Datenbank vorhanden ist oder die Datenbank für mehrere Vorgänge, z. B. ein Zusammenführungsjoin und Gruppierung mit Rollup, verwendet werden kann. Bei**Merge Join** handelt es sich um einen physischen Operator.|  
|![Nested Loops-Operator (Symbol)](../../2014/database-engine/media/nested-loops-32x.gif "Nested Loops-Operator (Symbol)")|`Nested Loops`|Der `Nested Loops`-Operator führt die logischen Operationen Inner Join, Left Outer Join, Left Semi Join und Left Anti Semi Join aus. Nested Loops-Joins führen für jede Zeile der äußeren Tabelle eine Suche in der inneren Tabelle aus, in der Regel mithilfe eines Indexes. Der Abfrageprozessor legt auf der Grundlage der geschätzten Kosten fest, ob die äußere Eingabe sortiert werden soll, um die Treffsicherheit der Suchvorgänge auf dem Index über die innere Eingabe zu verbessern. Alle Zeilen, die das (optionale) Prädikat in erfüllen die `Argument` -Spalte zurückgegeben, sofern zutreffend, basierend auf der logischen Operation ausgeführt wird. `Nested Loops` ist ein physischer Operator.|  
|![Nonclustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete-Operator (Symbol)")|`Nonclustered Index Delete`|Die `Nonclustered Index Delete` -Operator löscht Eingabezeilen aus dem nicht gruppierten Index im angegebenen die `Argument` Spalte. `Nonclustered Index Delete` ist ein physischer Operator.|  
|![Nonclustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert-Operator (Symbol)")|`Index Insert`|Die `Index Insert` -Operators werden Zeilen aus der Eingabe in den im angegebenen nicht gruppierten Index der `Argument` Spalte. Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. `Index Insert` ist ein physischer Operator.|  
|![Nonclustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan-Operator (Symbol)")|`Index Scan`|Die `Index Scan` -Operator Ruft alle Zeilen aus dem nicht gruppierten Index im angegebenen ab der `Argument` Spalte. Wenn ein optionales, in denen :() Prädikat in wird, der `Argument` Spalte, die nur die Zeilen, die das Prädikat erfüllen zurückgegeben werden. `Index Scan` ist ein logischer und physischer Operator.|  
|![Nonclustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered Index Seek-Operator (Symbol)")|`Index Seek`|Der `Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem nicht gruppierten Index abzurufen. Die `Argument` Spalte enthält den Namen des nicht gruppierten Index verwendet wird. Außerdem enthält sie auch das SEEK:()-Prädikat. Mit diesem Index werden von der Speicher-Engine nur die Zeilen verarbeitet, die das SEEK:()-Prädikat erfüllen. Optional kann ein WHERE:()-Prädikat enthalten sein, das von der Speicher-Engine für alle Zeilen ausgewertet wird, bei denen das SEEK:()-Prädikat erfüllt wird (es werden hierfür keine Indizes verwendet). Wenn die `Argument` Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in dem nicht gruppierte Index wurden sortiert. Wurde die ORDERED-Klausel nicht angegeben, so durchsucht die Speicher-Engine den Index auf die optimale Art (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. `Index Seek` ist ein logischer und physischer Operator.|  
|![Nonclustered Index Spool-Operator (Symbol)](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered Index Spool-Operator (Symbol)")|**Index Spool**|Die **Index Spool** physische Operator enthält, eine Suche :() Prädikat in der `Argument` Spalte. Die **Index Spool** -Operator scannt die Eingabezeilen, platziert eine Kopie jeder Zeile in einer verborgenen Spooldatei (gespeichert der `tempdb` -Datenbank und nur für die Dauer der Abfrage), und erstellt einen nicht gruppierten Index für die Zeilen. Dies ermöglicht es Ihnen, mithilfe der Indexsuchfunktionen nur die Zeilen auszugeben, die das SEEK:()-Prädikat erfüllen. Wenn der Operator zurückgesetzt wird (z. B. durch eine `Nested Loops` Operator) aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.|  
|![Nonclustered Index Update-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered Index Update-Operator (Symbol)")|`Nonclustered Index Update`|Die `Nonclustered Index Update` physischen-Operator aktualisiert Eingabezeilen in den im angegebenen nicht gruppierten Index der `Argument` Spalte. Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. `Nonclustered Index Update` ist ein physischer Operator.|  
|![Online Index Insert-Operator (Symbol)](../../2014/database-engine/media/online-index-32x.gif "Online Index Insert-Operator (Symbol)")|**Online Index Insert**|Der physische Operator **Online Index Insert** gibt an, dass ein Index online erstellt, geändert oder gelöscht wird. Die zugrunde liegenden Tabellendaten bleiben daher während des Indexvorgangs für Benutzer verfügbar.|  
|None|`Parallelism`|Die `Parallelism` -Operator führt die Distribute Streams, Gather Streams und Repartition streams logische Operationen. Die `Argument` -Spalten können ein PARTITION-Spalten :() Prädikat mit einer durch Trennzeichen getrennte Liste von partitionierenden Spalten enthalten. Die `Argument` Spalten darf auch eine ORDER BY :()-Prädikats Auflisten der Spalten die Sortierreihenfolge bei der Partitionierung beibehält. `Parallelism` ist ein physischer Operator.<br /><br /> Hinweis: Wenn eine Abfrage als parallele Abfrage kompiliert wurde, aber zur Laufzeit als serielle Abfrage ausgeführt, generierte Showplanausgabe mit SET STATISTICS XML oder mithilfe der **tatsächlichen Ausführungsplan einschließen** option [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] enthält nicht die `RunTimeInformation` -Element für die `Parallelism` Operator. In der SET STATISTICS PROFILE-Ausgabe, die tatsächliche Zeilenanzahl und die tatsächliche Anzahl der Ausführungen werden Nullen für die Anzeige der `Parallelism` Operator. Wenn eine der Bedingungen auftritt, bedeutet, dass die `Parallelism` -Operator nur während der Abfragekompilierung und nicht in der Laufzeit-Abfrageplan verwendet wurde. Beachten Sie, dass parallele Abfragepläne mitunter seriell ausgeführt werden, wenn der Server stark ausgelastet ist.|  
|![Parameter Table Scan-Operator (Symbol)](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter Table Scan-Operator (Symbol)")|`Parameter Table Scan`|Der `Parameter Table Scan`-Operator scannt eine Tabelle, die als Parameter in der aktuellen Abfrage dient. In der Regel wird dieser Operator für INSERT-Abfragen in einer gespeicherten Prozedur verwendet. `Parameter Table Scan` ist ein logischer und physischer Operator.|  
|None|**Partial Aggregate**|**Partial Aggregate** wird in parallelen Plänen verwendet. Hiermit wird eine Aggregatfunktion auf möglichst viele Eingabezeilen angewandt, damit das Schreiben auf den Datenträger (der so genannte "Überlauf") nicht erforderlich ist. `Hash Match` ist der einzige physische Operator (Iterator), der partitionsaggregation implementiert. **Partial Aggregate** ist ein logischer Operator.|  
|![Population Query-Cursoroperator (Symbol)](../../2014/database-engine/media/poulation-query-32x.gif "Population Query-Cursoroperator (Symbol)")|`Population Query`|Der `Population Query`-Operator füllt die Arbeitstabelle eines Cursors auf, wenn der Cursor geöffnet wird.|  
|![Refresh Query-Cursoroperator (Symbol)](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query-Cursoroperator (Symbol)")|`Refresh Query`|Der `Refresh Query`-Operator ruft aktuelle Daten für die Zeilen im Fetchpuffer ab.|  
|![Remote Delete-Operator (Symbol)](../../2014/database-engine/media/remote-delete-32x.gif "Remote Delete-Operator (Symbol)")|`Remote Delete`|Der `Remote Delete`-Operator löscht die Eingabezeilen in einem Remoteobjekt. `Remote Delete` ist ein logischer und physischer Operator.|  
|![Remote Index Seek-Showplanoperator](../../2014/database-engine/media/remote-index-scan-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Scan**|Der **Remote Index Scan** -Operator durchsucht den in der Argumentspalte angegebenen Remoteindex. **Remote Index Scan** ist ein logischer und physischer Operator.|  
|![Remote Index Seek-Showplanoperator](../../2014/database-engine/media/remote-index-seek-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Seek**|Der **Remote Index Seek** -Operator verwendet die Suchmöglichkeiten eines Remoteindexobjekts, um Zeilen abzurufen. Die `Argument` Spalte enthält den Namen des remote Index verwendet wird und die Verschiebung :() Prädikat. **Remote Index Seek** ist ein logischer und physischer Operator.|  
|![Remote Insert-Operator (Symbol)](../../2014/database-engine/media/remote-insert-32x.gif "Remote Insert-Operator (Symbol)")|**Remote Insert**|Der **Remote Insert** -Operator fügt die Eingabezeilen in ein Remoteobjekt ein. **Remote Insert** ist ein logischer und physischer Operator.|  
|![Remote Query-Operator (Symbol)](../../2014/database-engine/media/remote-query-32x.gif "Remote Query-Operator (Symbol)")|`Remote Query`|Durch den Operator `Remote Query` wird eine Abfrage an eine Remotequelle übermittelt. Der Text, der an den Remoteserver gesendeten Abfrage wird die `Argument` Spalte. `Remote Query` ist ein logischer und physischer Operator.|  
|![Remote Scan-Operator (Symbol)](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan-Operator (Symbol)")|`Remote Scan`|Der Operator `Remote Scan` überprüft ein Remoteobjekt. Der Name des Remoteobjekts wird in der `Argument` Spalte. `Remote Scan` ist ein logischer und physischer Operator.|  
|![Remote Update-Operator (Symbol)](../../2014/database-engine/media/remote-update-32x.gif "Remote Update-Operator (Symbol)")|`Remote Update`|Der `Remote Update`-Operator aktualisiert die Eingabezeilen in einem Remoteobjekt. `Remote Update` ist ein logischer und physischer Operator.|  
|![Repartition Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition Streams Parallelism-Operator (Symbol)")|**Repartition Streams**|Der **Repartition Streams** -Operator verarbeitet und generiert mehrere Datenströme von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn der Abfrageoptimierer einen Bitmapfilter verwendet, wird die Anzahl der Zeilen im Ausgabedatenstrom reduziert. Jeder Datensatz aus einem Eingabedatenstrom wird in einem Ausgabedatenstrom platziert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen und in mehrere geordnete Ausgabedatenströme zusammengeführt werden. Wenn die Ausgabe partitioniert ist, die `Argument` Spalte enthält einen PARTITIONSSPALTEN :() Prädikat und die Partitionierungsspalten. Wenn die Ausgabe sortiert ist, die `Argument` Spalte enthält eine ORDER BY :() Prädikat und die sortierten Spalten. **Repartition Streams** ist ein logischer Operator. Der Operator wird nur in parallelen Abfrageplänen verwendet.|  
|![Result-Sprachelement (Symbol)](../../2014/database-engine/media/result-32x.gif "Result-Sprachelement (Symbol)")|`Result`|Der `Result`-Operator stellt die Daten dar, die am Ende eines Abfrageplans zurückgegeben werden. Dies ist normalerweise das Stammelement eines Showplans. `Result` ist ein Sprachelement.|  
|![RID Lookup-Operator (Symbol)](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID Lookup-Operator (Symbol)")|`RID Lookup`|`RID Lookup` ist ein Bookmark Lookup für einen Heap, der eine bereitgestellte Zeilen-ID (RID) verwendet. Die `Argument` Spalte enthält die lesezeichenbeschriftung, suchen Sie nach der Zeile in der Tabelle und den Namen der Tabelle in der die Zeile, wird nachgeschlagen wird. `RID Lookup` wird stets durch eine NESTED LOOP JOIN-Anweisung begleitet. `RID Lookup` ist ein physischer Operator. Weitere Informationen zu Bookmark Lookups finden Sie unter „[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)“ im SQL Server-Blog von MSDN.|  
|None|`Right Anti Semi Join`|Der logische Operator `Right Anti Semi Join` gibt alle Zeilen aus der zweiten (unteren) Eingabe aus, für die keine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Eine übereinstimmende Zeile ist definiert als eine Zeile, die das Prädikat erfüllt die `Argument` Spalte (Wenn kein Prädikat vorhanden ist, wird jede Zeile eine übereinstimmende Zeile.). `Right Anti Semi Join` ist ein logischer Operator.|  
|None|`Right Outer Join`|Der `Right Outer Join`-Operator gibt alle Zeilen zurück, die den Join der zweiten (unteren) Eingabe mit der ersten (oberen) Eingabe erfüllen. Er gibt auch alle Zeilen aus der zweiten Eingabe mit NULL-Werten zurück, für die keine übereinstimmende Zeile in der ersten Eingabe vorhanden ist. Wenn kein joinprädikat in vorhanden ist. die `Argument` Spalte, die jede Zeile eine übereinstimmende Zeile ist. `Right Outer Join` ist ein logischer Operator.|  
|None|`Right Semi Join`|Der `Right Semi Join`-Operator gibt alle Zeilen aus der zweiten (unteren) Eingabe zurück, für die eine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Wenn kein joinprädikat in vorhanden ist. die `Argument` Spalte, die jede Zeile eine übereinstimmende Zeile ist. `Right Semi Join` ist ein logischer Operator.|  
|![Row Count Spool-Operator (Symbo)l](../../2014/database-engine/media/remote-count-spool-32x.gif "Row Count Spool-Operator (Symbol)")|**Row Count Spool**|Der **Row Count Spool** -Operator scannt die Eingabe, zählt, wie viele Zeilen vorhanden sind, und gibt dieselbe Anzahl an leeren Zeilen zurück. Dieser Operator wird verwendet, wenn es darauf ankommt, die Existenz von Zeilen und nicht ihren Inhalt zu überprüfen. Z. B. wenn ein `Nested Loops` Operator führt einen left Semi Join-Vorgang und der Join-Prädikat, die auf die innere Eingabe angewendet wird, kann ein Row Count Spool platziert werden, am Anfang der inneren Eingabe des der `Nested Loops` Operator. Die `Nested Loops` -Operator bestimmen, wie viele Zeilen vom Row Count Spool ausgegeben wurden, (da die eigentlichen Daten auf der Innenseite nicht erforderlich ist) zu bestimmen, ob die äußere Zeile zurückgegeben. Beim**Row Count Spool** -Operator handelt es sich um einen physischen Operator.|  
|![Segment-Operator (Symbol)](../../2014/database-engine/media/segment-32x.gif "Segment-Operator (Symbol)")|**Segment**|**Segment** ist ein physischer und logischer Operator. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Diese Spalten werden als Argumente im Operator **Segment** angezeigt. Anschließend gibt der Operator ein Segment nach dem anderen aus.|  
|None|`Segment Repartition`|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt. Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt. `Branch Repartition` und `Segment Repartition` sind logische Operatoren.|  
|![Sequence-Operator (Symbol)](../../2014/database-engine/media/sequence-32x.gif "Sequence-Operator (Symbol)")|`Sequence`|Der `Sequence`-Operator steuert umfangreiche Aktualisierungspläne. Er führt die Eingaben sequenziell aus (von oben nach unten). Jede Eingabe stellt in der Regel ein Update eines anderen Objekts dar. Der Operator gibt nur die Zeilen zurück, die aus der letzten (unteren) Eingabe stammen. `Sequence` ist ein logischer und physischer Operator.|  
|![Sequence Project-Operator (Symbol)](../../2014/database-engine/media/sequence-project-32x.gif "Sequence Project-Operator (Symbol)")|`Sequence Project`|Der `Sequence Project`-Operator fügt Spalten hinzu, um für eine geordnete Menge Berechnungen auszuführen. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Anschließend gibt der Operator ein Segment nach dem anderen aus. Diese Spalten werden im `Sequence Project`-Operator als Argumente angezeigt. `Sequence Project` ist ein logischer und physischer Operator.|  
|![Momentaufnahme-Cursoroperator (Symbol)](../../2014/database-engine/media/snapshot-32x.gif "Momentaufnahme-Cursoroperator (Symbol)")|**Momentaufnahme**|Mit dem **Snapshot** -Operator wird ein Cursor erstellt, der von anderen vorgenommene Änderungen nicht wahrnimmt.|  
|![Sort-Operator (Symbol)](../../2014/database-engine/media/sort-32x.gif "Sort-Operator (Symbol)")|`Sort`|Die `Sort` -Operator sortiert alle eingehenden Zeilen. Die `Argument` -Spalte enthält entweder ein DISTINCT ORDER BY :() Prädikat, wenn dieser Vorgang Duplikate entfernt werden, oder eine ORDER BY :() Prädikat mit einer durch Trennzeichen getrennte Liste der zu sortierenden Spalten. Die Spalten werden mit dem Präfix ASC versehen, wenn sie in aufsteigender Reihenfolge sortiert werden, oder mit der Zeichenfolge DESC, wenn sie in absteigender Reihenfolge sortiert werden. `Sort` ist ein logischer und physischer Operator.|  
|![Split-Operator (Symbol)](../../2014/database-engine/media/split-32x.gif "Split-Operator (Symbol)")|`Split`|Die `Split` Operator wird verwendet, um die Verarbeitung von Aktualisierungen zu optimieren. Er teilt jeden Aktualisierungsvorgang in einen Lösch- und einen Einfügevorgang auf. `Split` ist ein logischer und physischer Operator.|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Spool**|Die **Spool** -Operator wird ein Zwischenabfrageergebnis in die `tempdb` Datenbank.|  
|![Stream Aggregate-Operator (Symbol)](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream Aggregate-Operator (Symbol)")|`Stream Aggregate`|Der `Stream Aggregate`-Operator gruppiert Zeilen nach einer oder mehreren Spalten und berechnet einen oder mehrere Aggregatausdrücke, die von der Abfrage zurückgegeben wurden. Auf die Ausgabe dieses Operators kann durch spätere Operatoren in der Abfrage verwiesen werden, die Ausgabe kann an den Client zurückgegeben werden oder beides. Für den `Stream Aggregate`-Operator ist es erforderlich, dass die Eingabe innerhalb der Gruppen nach den Spalten sortiert ist. Der Optimierer verwendet vor diesem Operator einen `Sort`-Operator, wenn die Daten nicht bereits durch einen vorherigen `Sort`-Operator oder durch einen geordneten Indexsuch- oder Scanvorgang sortiert wurden. In der SHOWPLAN_ALL-Anweisung oder im grafischen Ausführungsplan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], die Spalten in GROUP BY-Prädikat finden Sie in der `Argument` Spalte und die Aggregatausdrücke finden Sie in der **Defined Values** Spalte. `Stream Aggregate` ist ein physischer Operator.|  
|![Switch-Operator (Symbol)](../../2014/database-engine/media/switch-32x.gif "Switch-Operator (Symbol)")|**Schalter**|**Switch** ist ein spezieller Verkettungsiterator, der über *n* Eingaben verfügt. Mit jedem **Switch** -Operator ist ein Ausdruck verbunden. Abhängig vom Rückgabewert des Ausdrucks (zwischen 0 und *n*-1) kopiert **Switch** den entsprechenden Eingabedatenstrom in den Ausgabedatenstrom. Eine Verwendungsmöglichkeit von **Switch** besteht in der Implementierung von Abfrageplänen, die schnelle Vorwärtscursor mit bestimmten Operatoren, z.B. dem **TOP** -Operator, enthalten. **Switch** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Table Delete-Operator (Symbol)r](../../2014/database-engine/media/table-delete-32x.gif "Table Delete-Operator (Symbol)")|`Table Delete`|Die `Table Delete` physischen-Operator löscht Zeilen aus der Tabelle, angegeben der `Argument` Spalte des Abfrageausführungsplans.|  
|![Table Insert-Operator (Symbol)](../../2014/database-engine/media/table-insert-32x.gif "Table Insert-Operator (Symbol)")|`Table Insert`|Die `Table Insert` -Operators werden Zeilen aus der Eingabe in der Tabelle, angegeben der `Argument` Spalte des Abfrageausführungsplans. Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. Wenn `Table Insert` keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus dem Insert-Operator selbst übernommen. `Table Insert` ist ein physischer Operator.|  
|![Table Merge-Operator](../../2014/database-engine/media/table-merge-32x.gif "Table Merge-Operator")|**Table Merge**|Der **Table Merge** -Operator wendet einen Mergedatenstrom auf einen Heap an. Der Operator löscht, aktualisiert oder fügt Zeilen in der Tabelle, angegeben der `Argument` -Spalte des Operators. Der tatsächliche ausgeführte Vorgang hängt von der Run-Time-Wert, der die **Aktion** in angegebene Spalte den `Argument` -Spalte des Operators. **Table Merge** ist ein physischer Operator.|  
|![Table Scan-Operator (Symbol)](../../2014/database-engine/media/table-scan-32x.gif "Table Scan-Operator (Symbol)")|`Table Scan`|Die `Table Scan` -Operator Ruft alle Zeilen aus der Tabelle im angegebenen ab der `Argument` Spalte des Abfrageausführungsplans. Wenn :() eine WHERE-Prädikat wird in der `Argument` Spalte, die nur die Zeilen, die das Prädikat erfüllen zurückgegeben werden. `Table Scan` ist ein logischer und physischer Operator.|  
|![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|**Table Spool**|Der **Table Spool** -Operator scannt die Eingabe und platziert eine Kopie jeder Zeile in einer verborgenen Spooltabelle, die in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert und nur für die Dauer der Abfrage vorhanden ist. Wenn der Operator zurückgesetzt wird (z. B. durch eine `Nested Loops` Operator) aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. **Table Spool** ist ein physischer Operator.|  
|![Table Update-Operator (Symbol)](../../2014/database-engine/media/table-update-32x.gif "Table Update-Operator (Symbol)")|`Table Update`|Die `Table Update` physischen-Operator aktualisiert Eingabezeilen in der Tabelle, angegeben der `Argument` Spalte des Abfrageausführungsplans. Das SET:()-Prädikat bestimmt den Wert jeder aktualisierten Spalte. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie an anderer Stelle dieser Abfrage verwiesen werden.|  
|![Tabellenwertfunktion-Operator (Symbol)](../../2014/database-engine/media/table-valued-function-32x.gif "-Tabellenwertfunktion-Operator (Symbol)")|**Table-valued Function**|Mit dem Operator **Tabellenwertfunktion** wird eine Tabellenwertfunktion ausgewertet ( [!INCLUDE[tsql](../includes/tsql-md.md)] oder CLR), und die Ergebniszeilen werden in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert. Wenn die übergeordneten Iteratoren die Zeilen anfordern **Funktion mit Tabellenrückgabe** gibt die Zeilen aus `tempdb`.<br /><br /> Abfragen mit Aufrufen von Tabellenwertfunktionen generieren Abfragepläne mit dem **Tabellenwertfunktion** -Iterator. Die**Tabellenwertfunktion** kann mit verschiedenen Parameterwerten analysiert werden:<br /><br /> Der**Tabellenwertfunktion-XML-Leser** gibt einen XML-BLOB als Parameter ein und erstellt ein Rowset, das XML-Knoten in der XML-Dokumentreihenfolge darstellt. Andere Eingabeparameter können die zurückgegebenen XML-Knoten auf eine Teilmenge von XML-Dokumenten einschränken.<br /><br /> Der**Tabellenwertfunktion-XML-Leser mit XPath-Filter** ist ein spezieller Typ von **Tabellenwertfunktion-XML-Leser** , der die Ausgabe auf XML-Knoten einschränkt, die einen XPath-Ausdruck erfüllen.<br /><br /> <br /><br /> Die**Tabellenwertfunktion** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Top-Operator (Symbol)](../../2014/database-engine/media/top-32x.gif "Top-Operator (Symbol)")|**Top**|Der **Top** -Operator scannt die Eingabe und gibt nur die angegebene Anzahl bzw. den angegebenen Prozentsatz von Zeilen zurück, meist basierend auf einer Sortierreihenfolge. Die `Argument` Spalte kann eine Liste der Spalten, die auf Verbindungen überprüft werden, sind enthalten. In Updateplänen wird der **Top** -Operator verwendet, um die Einschränkung der Zeilenanzahl zu erzwingen. **Top** ist sowohl ein logischer als auch physischer Operator. **Top** ist sowohl ein logischer als auch physischer Operator.|  
|None|**Top N Sort**|**Top N Sort** ist vergleichbar mit der `Sort` -Iterator, außer, dass nur die erste *N* benötigt, und nicht das gesamte Resultset. Bei kleinen Werten für *N* versucht die [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]-Abfrageausführungs-Engine, den gesamten Sortiervorgang im Arbeitsspeicher auszuführen. Bei großen Werten für *N* greift die Abfrageausführungs-Engine auf die mehr generische Methode der Sortierung zurück, für die *N* kein Parameter ist.|  
|![Erweiterter Operator (UDX – Symbol)](../../2014/database-engine/media/udx-32x.gif "Erweiterter Operator (UDX – Symbol)")|`UDX`|Erweiterte Operatoren (UDX) implementieren einen von vielen XQuery- und XPath-Vorgängen in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Alle UDX-Operatoren sind sowohl logische als auch physische Operatoren.<br /><br /> Mit dem erweiterten Operator (UDX) `FOR XML` wird das relationale Rowset serialisiert, das in die XML-Darstellung einer einzelnen BLOB-Spalte in einer einzigen Ausgabezeile eingegeben wird. Bei diesem XML-Aggregationsoperator wird die Reihenfolge berücksichtigt.<br /><br /> Der erweiterte Operator (UDX) `XML SERIALIZER` ist ein XML-Aggregationsoperator, bei dem die Reihenfolge berücksichtigt wird. Er gibt Zeilen ein, die XML-Knoten oder XQuery-Skalarwerte in der XML-Dokumentreihenfolge darstellen, und erstellt eine serialisierte XML-BLOB-Spalte in einer einzelnen XML-Spalte in einer einzigen Ausgabezeile.<br /><br /> Der erweiterte Operator (UDX) `XML FRAGMENT SERIALIZER` ist eine Sonderform von `XML SERIALIZER`, womit Eingabezeilen verarbeitet werden, die XML-Fragmente darstellen, die in der XQuery-Erweiterung zum Ändern von Einfügungsdaten eingefügt werden.<br /><br /> Der erweiterte Operator (UDX) `XQUERY STRING` wertet den XQuery-Zeichenfolgenwert von Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der den Zeichenfolgenwert der Eingabe enthält.<br /><br /> Der erweiterte Operator (UDX) `XQUERY LIST DECOMPOSER` ist ein XQuery-Listendekompositionsoperator. Für jede Eingabezeile, die einen XML-Knoten darstellt, erstellt dieser Operator mindestens eine Zeile, die einen XQuery-Skalarwert mit einem Listenelementwert darstellt, falls die Eingabe vom XSD-Listentyp ist.<br /><br /> Der erweiterte Operator (UDX) `XQUERY DATA` wertet die XQuery-Funktion fn:data() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:data()** enthält.<br /><br /> Der erweiterte Operator `XQUERY CONTAINS` wertet die XQuery-Funktion fn:contains() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:contains()** enthält.<br /><br /> Erweiterte Operator `UPDATE XML NODE` aktualisiert XML-Knoten in der XQuery-ersetzen-Erweiterung zum Ändern von Daten in die **modify()** Methode XML-Typ.|  
|None|**Union**|Der **Union** -Operator scannt mehrere Eingaben und gibt alle gescannten Zeilen aus, wobei Duplikate entfernt werden. **Union** ist ein logischer Operator.|  
|![Update (Datenbank-Engine – Operatorsymbol)](../../2014/database-engine/media/update-32x.gif "Update (Datenbank-Engine – Operatorsymbol)")|`Update`|Die `Update` -Operators wird jede Zeile aus der Eingabe in das Objekt, das im angegebenen aktualisiert die `Argument` Spalte des Abfrageausführungsplans. `Update` ist ein logischer Operator. Der physische Operator ist `Table Update`, `Index Update` oder `Clustered Index Update`.|  
|While-Sprachelement (Symbol)![While-Sprachelement (Symbol)](../../2014/database-engine/media/while-32x.gif "While-Sprachelement (Symbol)")|`While`|Der `While`-Operator implementiert die WHILE-Schleife von [!INCLUDE[tsql](../includes/tsql-md.md)]. `While` ist ein Sprachelement|  
|![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|`Window Spool`|Der `Window Spool`-Operator erweitert jede Zeile in den Satz von Zeilen, die das ihm zugeordnete Fenster darstellen. In einer Abfrage definiert die OVER-Klausel das Fenster innerhalb eines Abfrageresultsets, und eine Fensterfunktion berechnet dann einen Wert für jede Zeile im Fenster. `Window Spool` ist ein logischer und physischer Operator.|  
  
  
