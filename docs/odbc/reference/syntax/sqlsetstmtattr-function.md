---
title: SQLSetStmtAttr-Funktion | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287263"
---
# <a name="sqlsetstmtattr-function"></a>SQLSetStmtAttr-Funktion
**Konformität**  
 Eingeführte Version: ODBC 3.0-Normkonformität: ISO 92  
  
 **Zusammenfassung**  
 **SQLSetStmtAttr** legt Attribute fest, die sich auf eine Anweisung beziehen.  
  
> [!NOTE]
>  Weitere Informationen dazu, wie der Treiber-Manager diese Funktion zuordnet, wenn eine ODBC *3.x-Anwendung* mit einem ODBC *2.x-Treiber* arbeitet, finden Sie unter [Mapping Replacement Functions for Backward Compatibility of Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntax  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumente  
 *StatementHandle*  
 [Eingabe] Anweisungshandle.  
  
 *Attribut*  
 [Eingabe] Option zum Festlegen, aufgeführt in "Kommentare".  
  
 *ValuePtr*  
 [Eingabe] Wert, der *Attribut*zugeordnet werden soll. Abhängig vom Wert von *Attribut*ist *ValuePtr* einer der folgenden:  
  
-   Ein ODBC-Deskriptorhandle.  
  
-   Ein SQLUINTEGER-Wert.  
  
-   Ein SQLULEN-Wert.  
  
-   Ein Zeiger auf einen der folgenden Punkte:  
  
    -   Eine null-terminierte Zeichenfolge.  
  
    -   Ein binärer Puffer.  
  
    -   Ein Wert oder Array vom Typ SQLLEN, SQLULEN oder SQLUSMALLINT.  
  
    -   Ein treiberdefinierter Wert.  
  
 Wenn das *Attributargument* ein treiberspezifischer Wert ist, kann *ValuePtr* eine signierte ganze Zahl sein.  
  
 *StringLength*  
 [Eingabe] Wenn *Attribute* ein ODBC-definiertes Attribut ist und *ValuePtr* auf eine Zeichenfolge oder \*einen Binärpuffer verweist, sollte dieses Argument die Länge von *ValuePtr*sein. Wenn *Attribute* ein ODBC-definiertes Attribut und *ValuePtr* eine ganze Zahl ist, wird *StringLength* ignoriert.  
  
 Wenn *Attribute* ein treiberdefiniertes Attribut ist, gibt die Anwendung die Art des Attributs für den Treiber-Manager an, indem das *StringLength-Argument* festgelegt wird. *StringLength* kann die folgenden Werte haben:  
  
-   Wenn *ValuePtr* ein Zeiger auf eine Zeichenfolge ist, ist *StringLength* die Länge der Zeichenfolge oder SQL_NTS.  
  
-   Wenn *ValuePtr* ein Zeiger auf einen Binärpuffer ist, platziert die Anwendung das Ergebnis des*SQL_LEN_BINARY_ATTR(Länge*) Makros in *StringLength*. Dadurch wird ein negativer Wert in *StringLength*platziert.  
  
-   Wenn *ValuePtr* ein Zeiger auf einen anderen Wert als eine Zeichenfolge oder eine Binärzeichenfolge ist, sollte *StringLength* den Wert SQL_IS_POINTER haben.  
  
-   Wenn *ValuePtr* einen Wert mit fester Länge enthält, ist *StringLength* entweder SQL_IS_INTEGER oder SQL_IS_UINTEGER.  
  
## <a name="returns"></a>Rückgabe  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR oder SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnose  
 Wenn **SQLSetStmtAttr** SQL_ERROR oder SQL_SUCCESS_WITH_INFO zurückgibt, kann ein zugeordneter SQLSTATE-Wert abgerufen werden, indem **SQLGetDiagRec** mit einem *HandleType* von SQL_HANDLE_STMT und einem *Handle* von *StatementHandle*aufgerufen wird. In der folgenden Tabelle sind die SQLSTATE-Werte aufgeführt, die normalerweise von **SQLSetStmtAttr** zurückgegeben werden, und es werden die SQLSTATE-Werte im Kontext dieser Funktion erläutert. Die Notation "(DM)" geht den Beschreibungen von SQLSTATEs voraus, die vom Treiber-Manager zurückgegeben werden. Der jedem SQLSTATE-Wert zugeordnete Rückgabecode ist SQL_ERROR, sofern nicht anders angegeben.  
  
|SQLSTATE|Fehler|Beschreibung|  
|--------------|-----------|-----------------|  
|01000|Allgemeine Warnung|Treiberspezifische Informationsmeldung. (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|01S02|Optionswert geändert|Der Treiber unterstützte nicht den in *ValuePtr*angegebenen Wert, oder der in *ValuePtr* angegebene Wert war aufgrund von Implementierungsarbeitsbedingungen ungültig, sodass der Treiber einen ähnlichen Wert ersetzte. (**SQLGetStmtAttr** kann aufgerufen werden, um den vorübergehend ersetzten Wert zu bestimmen.) Der Ersatzwert ist für das *StatementHandle gültig,* bis der Cursor geschlossen wird. Die Anweisungsattribute, die geändert werden können, sind:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|08S01|Kommunikationsverbindungsfehler|Die Kommunikationsverbindung zwischen dem Treiber und der Datenquelle, mit der der Treiber verbunden war, ist fehlgeschlagen, bevor die Verarbeitung abgeschlossen wurde.|  
|24.000|Ungültiger Cursorstatus|Das *Attribut* war SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR oder SQL_ATTR_USE_BOOKMARKS, und der Cursor war geöffnet.|  
|HY000|Allgemeiner Fehler|Es ist ein Fehler aufgetreten, für den es keine bestimmte SQLSTATE gab und für den keine implementierungsspezifische SQLSTATE definiert wurde. Die von **SQLGetDiagRec** im * \*MessageText-Puffer* zurückgegebene Fehlermeldung beschreibt den Fehler und seine Ursache.|  
|HY001|Speicherzuweisungsfehler|Der Treiber konnte den erforderlichen Speicher nicht zuweisen, um die Ausführung oder den Abschluss der Funktion zu unterstützen.|  
|HY009|Ungültige Verwendung des NULL-Zeigers|Das *Attributargument* identifizierte ein Anweisungsattribut, das ein Zeichenfolgenattribut erforderte, und das *ValuePtr-Argument* war ein Nullzeiger.|  
|HY010|Funktionssequenzfehler|(DM) Für das Verbindungshandle, das dem *StatementHandle*zugeordnet ist, wurde eine asynchron ausgeführte Funktion aufgerufen. Diese asynchrone Funktion wurde noch ausgeführt, als die **SQLSetStmtAttr-Funktion** aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**oder **SQLMoreResults** wurde für das *StatementHandle* aufgerufen und SQL_PARAM_DATA_AVAILABLE zurückgegeben. Diese Funktion wurde aufgerufen, bevor Daten für alle gestreamten Parameter abgerufen wurden.<br /><br /> (DM) Eine asynchron ausgeführte Funktion wurde für den *StatementHandle* aufgerufen und wurde noch ausgeführt, als diese Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**oder **SQLSetPos** wurde für das *StatementHandle* aufgerufen und SQL_NEED_DATA zurückgegeben. Diese Funktion wurde aufgerufen, bevor Daten für alle Daten-at-Execution-Parameter oder Spalten gesendet wurden.|  
|HY011|Attribut kann jetzt nicht festgelegt werden|Das *Attribut* wurde SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR oder SQL_ ATTR_USE_BOOKMARKS, und die Anweisung wurde vorbereitet.|  
|HY013|Speicherverwaltungsfehler|Der Funktionsaufruf konnte nicht verarbeitet werden, da auf die zugrunde liegenden Speicherobjekte nicht zugegriffen werden konnte, möglicherweise aufgrund niedriger Speicherbedingungen.|  
|HY017|Ungültige Verwendung eines automatisch zugewiesenen Deskriptor-Handles|(DM) Das *Attributargument* wurde SQL_ATTR_IMP_ROW_DESC oder SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) Das *Attributargument* wurde SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und der Wert in *ValuePtr* war ein implizit zugewiesenes Deskriptor-Handle, das nicht das Handle war, das ursprünglich für die ARD oder APD zugewiesen wurde.|  
|HY024|Ungültiger Attributwert|Angesichts des angegebenen *Attributwerts* wurde in *ValuePtr*ein ungültiger Wert angegeben. (Der Treiber-Manager gibt diese SQLSTATE nur für Verbindungs- und Anweisungsattribute zurück, die einen diskreten Satz von Werten akzeptieren, z. B. SQL_ATTR_ACCESS_MODE oder SQL_ ATTR_ASYNC_ENABLE. Für alle anderen Verbindungs- und Anweisungsattribute muss der Treiber den in *ValuePtr*angegebenen Wert überprüfen.)<br /><br /> Das *Attributargument* wurde SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und *ValuePtr* war ein explizit zugewiesenes Deskriptorhandle, das sich nicht in derselben Verbindung wie das *StatementHandle-Argument* befindet.|  
|HY090|Ungültige Zeichenfolge oder Pufferlänge|(DM) * \*ValuePtr* ist eine Zeichenfolge, und das *StringLength-Argument* war kleiner als 0, wurde aber nicht SQL_NTS.|  
|HY092|Ungültiger Attribut-/Optionsbezeichner|(DM) Der für das Argument *Attribut* angegebene Wert war für die vom Treiber unterstützte ODBC-Version ungültig.<br /><br /> (DM) Der für das Argument *Attribut* angegebene Wert war ein schreibgeschütztes Attribut.|  
|HY117|Die Verbindung wird aufgrund eines unbekannten Transaktionsstatus unterbrochen. Nur Trennen und Schreibgeschützte sind zulässig.|(DM) Weitere Informationen zum angehaltenen Zustand finden Sie unter [SQLEndTran-Funktion](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Optionale Funktion nicht implementiert|Der für das Argument *Attribut* angegebene Wert war ein gültiges ODBC-Anweisungsattribut für die vom Treiber unterstützte ODBC-Version, wurde jedoch vom Treiber nicht unterstützt.<br /><br /> Das *Attributargument* wurde SQL_ATTR_ASYNC_ENABLE, und ein Aufruf von **SQLGetInfo** mit einem *InfoType* von SQL_ASYNC_MODE gibt SQL_AM_CONNECTION zurück.<br /><br /> Das *Attributargument* wurde SQL_ATTR_ENABLE_AUTO_IPD, und der Wert des Verbindungsattributs SQL_ATTR_AUTO_IPD wurde SQL_FALSE.|  
|HYT01|Verbindungstimeout abgelaufen|Der Verbindungstimeoutzeitraum ist abgelaufen, bevor die Datenquelle auf die Anforderung geantwortet hat. Der Verbindungstimeoutzeitraum wird über **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT festgelegt.|  
|IM001|Treiber unterstützt diese Funktion nicht|(DM) Der dem *StatementHandle* zugeordnete Treiber unterstützt die Funktion nicht.|  
|S1118|Treiber unterstützt keine asynchrone Benachrichtigung|Wenn **Sie SQLSetStmtAttr** aufrufen, um SQL_ATTR_ASYNC_STMT_EVENT festzulegen; asynchrone Benachrichtigung wird vom Treiber nicht unterstützt.|  
  
## <a name="comments"></a>Kommentare  
 Anweisungsattribute für eine Anweisung bleiben so lange in Kraft, bis sie durch einen anderen Aufruf von **SQLSetStmtAttr** geändert werden oder bis die Anweisung durch Aufrufen von **SQLFreeHandle**gelöscht wird. Wenn **Sie SQLFreeStmt** mit der Option SQL_CLOSE, SQL_UNBIND oder SQL_RESET_PARAMS aufrufen, werden Anweisungsattribute nicht zurückgesetzt.  
  
 Einige Anweisungsattribute unterstützen die Ersetzung eines ähnlichen Werts, wenn die Datenquelle den in *ValuePtr*angegebenen Wert nicht unterstützt. In solchen Fällen gibt der Treiber SQL_SUCCESS_WITH_INFO und SQLSTATE 01S02 zurück (Optionswert geändert). Wenn *Attribut* beispielsweise SQL_ATTR_CONCURRENCY und *ValuePtr* SQL_CONCUR_ROWVER ist und die Datenquelle dies nicht unterstützt, ersetzt der Treiber SQL_CONCUR_VALUES und gibt SQL_SUCCESS_WITH_INFO zurück. Um den ersetzten Wert zu bestimmen, ruft eine Anwendung **SQLGetStmtAttr**auf.  
  
 Das Format der mit *ValuePtr* festgelegten Informationen hängt vom angegebenen *Attribut*ab. **SQLSetStmtAttr** akzeptiert Attributinformationen in einem von zwei verschiedenen Formaten: einer Zeichenfolge oder einem Ganzzahlwert. Das Format der einzelnen Attribute wird in der Beschreibung des Attributs angegeben. Dieses Format gilt für die Informationen, die für jedes Attribut in **SQLGetStmtAttr**zurückgegeben werden. Zeichenzeichenfolgen, auf die das *ValuePtr-Argument* von **SQLSetStmtAttr** zeigt, haben die Länge *von StringLength*.  
  
> [!NOTE]
>  Die Möglichkeit, Anweisungsattribute auf Verbindungsebene durch Aufrufen von **SQLSetConnectAttr** festzulegen, ist in ODBC *3.x*veraltet. ODBC *3.x-Anwendungen* sollten niemals Anweisungsattribute auf Verbindungsebene festlegen. ODBC *3.x-Anweisungsattribute* können nicht auf Verbindungsebene festgelegt werden, mit Ausnahme der Attribute SQL_ATTR_METADATA_ID und SQL_ATTR_ASYNC_ENABLE, die sowohl Verbindungsattribute als auch Anweisungsattribute sind und entweder auf Verbindungsebene oder auf Anweisungsebene festgelegt werden können.  
> 
> [!NOTE]
>  ODBC *3.x-Treiber* müssen diese Funktionalität nur unterstützen, wenn sie mit ODBC *2.x-Anwendungen* arbeiten sollten, die ODBC *2.x-Anweisungsoptionen* auf Verbindungsebene festlegen. Weitere Informationen finden Sie unter "Festlegen von Anweisungsoptionen auf Verbindungsebene" unter [SQLSetConnectOption Mapping](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) in Anhang G: Treiberrichtlinien für Abwärtskompatibilität.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Anweisungsattribute, die Deskriptorfelder festlegen  
 Viele Anweisungsattribute entsprechen einem Headerfeld eines Deskriptors. Das Festlegen dieser Attribute führt tatsächlich zur Einstellung der Deskriptorfelder. Das Festlegen von Feldern durch einen Aufruf von **SQLSetStmtAttr** und nicht nach **SQLSetDescField** hat den Vorteil, dass ein Deskriptorhandle für den Funktionsaufruf nicht abgerufen werden muss.  
  
> [!CAUTION]  
>  Das Aufrufen von **SQLSetStmtAttr** für eine Anweisung kann sich auf andere Anweisungen auswirken. Dies geschieht, wenn die der Erklärung zugeordnete APD oder ARD explizit zugeordnet und auch anderen Aussagen zugeordnet wird. Da **SQLSetStmtAttr** die APD oder ARD ändert, gelten die Änderungen für alle Anweisungen, denen dieser Deskriptor zugeordnet ist. Wenn dies nicht das erforderliche Verhalten ist, sollte die Anwendung diesen Deskriptor von den anderen Anweisungen trennen (durch Aufrufen von **SQLSetStmtAttr,** um das feld SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC auf ein anderes Deskriptor-Handle festzulegen), bevor **SQLSetStmtAttr** erneut aufgerufen wird.  
  
 Wenn ein Deskriptorfeld als Ergebnis des entsprechenden Anweisungsattributs festgelegt wird, wird das Feld nur für die anwendbaren Deskriptoren festgelegt, die derzeit der durch das *StatementHandle-Argument* identifizierten Anweisung zugeordnet sind, und die Attributeinstellung wirkt sich nicht auf Deskriptoren aus, die dieser Anweisung in Zukunft zugeordnet sein könnten. Wenn ein Deskriptorfeld, das auch ein Anweisungsattribut ist, durch einen Aufruf von **SQLSetDescField**festgelegt wird, wird das entsprechende Anweisungsattribut festgelegt. Wenn ein explizit zugewiesener Deskriptor von einer Anweisung getrennt wird, wird ein Anweisungsattribut, das einem Headerfeld entspricht, auf den Wert des Felds im implizit zugewiesenen Deskriptor zurückgesetzt.  
  
 Wenn eine Anweisung zugewiesen wird (siehe [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), werden vier Deskriptor-Handles automatisch zugewiesen und der Anweisung zugeordnet. Explizit zugewiesene Deskriptor-Handles können der Anweisung zugeordnet werden, indem **SQLAllocHandle** mit einem *fHandleType* von SQL_HANDLE_DESC aufgerufen wird, um ein Deskriptor-Handle zuzuweisen, und dann **SQLSetStmtAttr** aufrufen, um das Deskriptor-Handle der Anweisung zuzuordnen.  
  
 Die Anweisungsattribute in der folgenden Tabelle entsprechen Deskriptorheaderfeldern.  
  
|Statement-Attribut|Kopfzeilenfeld|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Anweisungsattribute  
 Die aktuell definierten Attribute und die Version von ODBC, in der sie eingeführt wurden, sind in der folgenden Tabelle dargestellt. Es wird erwartet, dass mehr Attribute von Treibern definiert werden, um verschiedene Datenquellen zu nutzen. Ein Bereich von Attributen wird von ODBC reserviert. Treiberentwickler müssen Werte für ihre eigene treiberspezifische Verwendung von Open Group reservieren. Weitere Informationen finden Sie unter [Treiberspezifische Datentypen, Deskriptortypen, Informationstypen, Diagnosetypen und Attribute](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|*ValuePtr-Inhalt*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Das Handle für die APD für nachfolgende Aufrufe von **SQLExecute** und **SQLExecDirect** im Anweisungshandle. Der Anfangswert dieses Attributs ist der Deskriptor, der implizit zugewiesen wurde, als die Anweisung ursprünglich zugewiesen wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle festgelegt ist, das ursprünglich für den Deskriptor zugewiesen wurde, wird ein explizit zugewiesenes APD-Handle, das zuvor dem Anweisungshandle zugeordnet war, davon getrennt, und das Anweisungshandle wird auf das implizit zugewiesene APD-Handle zurückgesetzt.<br /><br /> Dieses Attribut kann nicht auf ein Deskriptor-Handle festgelegt werden, das implizit für eine andere Anweisung oder für ein anderes Deskriptor-Handle zugewiesen wurde, das implizit für dieselbe Anweisung festgelegt wurde. implizit zugewiesene Deskriptor-Handles können nicht mit mehr als einer Anweisung oder einem Deskriptor-Handle verknüpft werden.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Das Handle an die ARD für nachfolgende Abrufe auf dem Statement-Handle. Der Anfangswert dieses Attributs ist der Deskriptor, der implizit zugewiesen wurde, als die Anweisung ursprünglich zugewiesen wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das handle festgelegt ist, das ursprünglich für den Deskriptor zugewiesen wurde, wird ein explizit zugeordnetes ARD-Handle, das zuvor dem Anweisungshandle zugeordnet war, davon getrennt, und das Anweisungshandle wird auf das implizit zugeordnete ARD-Handle zurückgesetzt.<br /><br /> Dieses Attribut kann nicht auf ein Deskriptor-Handle festgelegt werden, das implizit für eine andere Anweisung oder für ein anderes Deskriptor-Handle zugewiesen wurde, das implizit für dieselbe Anweisung festgelegt wurde. implizit zugewiesene Deskriptor-Handles können nicht mit mehr als einer Anweisung oder einem Deskriptor-Handle verknüpft werden.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob eine Funktion, die mit der angegebenen Anweisung aufgerufen wird, asynchron ausgeführt wird:<br /><br /> SQL_ASYNC_ENABLE_OFF = Asynchrone Ausführungsunterstützung auf Anweisungsebene deaktivieren (Standard).<br /><br /> SQL_ASYNC_ENABLE_ON = Asynchrone Ausführungsunterstützung auf Anweisungsebene aktivieren.<br /><br /> Weitere Informationen finden Sie unter [Asynchrone Ausführung (Polling-Methode)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Bei Treibern mit asynchroner Ausführungsunterstützung auf Anweisungsebene ist das Anweisungsattribut SQL_ATTR_ASYNC_ENABLE schreibgeschützt. Sein Wert entspricht dem Wert des Attributs der Verbindungsebene mit demselben Namen zum Zeitpunkt der Zuweisung des Anweisungshandles.<br /><br /> Aufrufen von **SQLSetStmtAttr** zum Festlegen SQL_ATTR_ASYNC_ENABLE wenn der SQL_ASYNC_MODE *InfoType* SQL_AM_CONNECTION sqlSTATE HYC00 zurückgibt (Optionale Funktion nicht implementiert). Weitere Informationen finden Sie unter [SQLSetConnectAttr-Funktion.](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Ein SQLPOINTER-Wert, der ein Ereignishandle ist.<br /><br /> Die Benachrichtigung über den Abschluss asynchroner Funktionen wird durch Aufrufen von **SQLSetStmtAttr** aktiviert, um das **SQL_ATTR_ASYNC_STMT_EVENT-Attribut** festzulegen und das Ereignishandle anzugeben.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Ein SQLPOINTER für die asynchrone Rückruffunktion.<br /><br /> Nur der Treiber-Manager kann die **SQLSetStmtAttr-Funktion** eines Treibers mit diesem Attribut aufrufen.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Ein SQLPOINTER zur Kontextstruktur<br /><br /> Nur der Treiber-Manager kann die **SQLSetStmtAttr-Funktion** eines Treibers mit diesem Attribut aufrufen.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Ein SQLULEN-Wert, der die Cursorparallelität angibt:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor ist schreibgeschützt. Aktualisierungen sind nicht zulässig.<br /><br /> SQL_CONCUR_LOCK = Cursor verwendet die niedrigste Sperrebene, die ausreicht, um sicherzustellen, dass die Zeile aktualisiert werden kann.<br /><br /> SQL_CONCUR_ROWVER = Cursor verwendet eine optimistische Parallelitätssteuerung und vergleicht Zeilenversionen wie SQLBase ROWID oder Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor verwendet eine optimistische Parallelitätssteuerung, um Werte zu vergleichen.<br /><br /> Der Standardwert für SQL_ATTR_CONCURRENCY ist SQL_CONCUR_READ_ONLY.<br /><br /> Dieses Attribut kann für einen geöffneten Cursor nicht angegeben werden. Weitere Informationen finden Sie unter [Parallelitätstypen](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Wenn das SQL_ATTR_CURSOR_TYPE *Attribut* in einen Typ geändert wird, der den aktuellen Wert von SQL_ATTR_CONCURRENCY nicht unterstützt, wird der Wert SQL_ATTR_CONCURRENCY zur Ausführungszeit geändert und eine Warnung ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn der Treiber die **SELECT FOR UPDATE-Anweisung** unterstützt und eine solche Anweisung ausgeführt wird, während der Wert von SQL_ATTR_CONCURRENCY auf SQL_CONCUR_READ_ONLY festgelegt ist, wird ein Fehler zurückgegeben. Wenn der Wert von SQL_ATTR_CONCURRENCY in einen Wert geändert wird, den der Treiber für einen Bestimmten Wert von SQL_ATTR_CURSOR_TYPE, jedoch nicht für den aktuellen Wert von SQL_ATTR_CURSOR_TYPE unterstützt, wird der Wert von SQL_ATTR_CURSOR_TYPE zur Ausführungszeit geändert, und SQLSTATE 01S02 (Optionswert geändert) wird ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn die angegebene Parallelität von der Datenquelle nicht unterstützt wird, ersetzt der Treiber eine andere Parallelität und gibt SQLSTATE 01S02 zurück (Optionswert geändert). Für SQL_CONCUR_VALUES ersetzt der Fahrer SQL_CONCUR_ROWVER und umgekehrt. Für SQL_CONCUR_LOCK ersetzt der Fahrer, in der Reihenfolge, SQL_CONCUR_ROWVER oder SQL_CONCUR_VALUES. Die Gültigkeit des ersetzten Wertes wird erst zur Ausführungszeit überprüft.<br /><br /> Weitere Informationen zur Beziehung zwischen SQL_ATTR_CONCURRENCY und den anderen Cursorattributen finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Ein SQLULEN-Wert, der die Unterstützungsstufe angibt, die die Anwendung benötigt. Das Festlegen dieses Attributs wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute aus.**<br /><br /> SQL_NONSCROLLABLE = Scrollbare Cursor sind für das Anweisungshandle nicht erforderlich. Wenn die Anwendung **SQLFetchScroll** für dieses Handle aufruft, ist der einzige gültige Wert von *FetchOrientation* SQL_FETCH_NEXT. Dies ist die Standardoption.<br /><br /> SQL_SCROLLABLE = Scrollbare Cursor sind für das Anweisungshandle erforderlich. Beim Aufrufen von **SQLFetchScroll**kann die Anwendung einen beliebigen gültigen Wert von *FetchOrientation*angeben und die Cursorpositionierung in anderen Modi als dem sequenziellen Modus erreichen.<br /><br /> Weitere Informationen zu scrollbaren Cursorn finden Sie unter [Scrollable Cursors](../../../odbc/reference/develop-app/scrollable-cursors.md). Weitere Informationen zur Beziehung zwischen SQL_ATTR_CURSOR_SCROLLABLE und den anderen Cursorattributen finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob Cursor im Anweisungshandle die Änderungen sichtbar machen, die an einem Ergebnissatz durch einen anderen Cursor vorgenommen wurden. Das Festlegen dieses Attributs wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute aus.** Eine Anwendung kann den Wert dieses Attributs zurücklesen, um seinen Anfangszustand oder seinen Zustand zu erhalten, wie zuletzt von der Anwendung festgelegt.<br /><br /> SQL_UNSPECIFIED = Es ist nicht angegeben, was der Cursortyp ist und ob Cursor im Anweisungshandle die Änderungen sichtbar machen, die an einem Ergebnissatz durch einen anderen Cursor vorgenommen wurden. Cursor im Anweisungshandle können keine, keine oder alle derartigen Änderungen sichtbar machen. Dies ist die Standardoption.<br /><br /> SQL_INSENSITIVE = Alle Cursor im Anweisungshandle zeigen das Resultset an, ohne dass Änderungen widergespiegelt werden, die von einem anderen Cursor daran vorgenommen wurden. Unempfindliche Cursor sind schreibgeschützt. Dies entspricht einem statischen Cursor, der eine schreibgeschützte Parallelität hat.<br /><br /> SQL_SENSITIVE = Alle Cursor im Anweisungshandle machen alle Änderungen sichtbar, die von einem anderen Cursor an einem Resultset vorgenommen wurden.<br /><br /> Weitere Informationen zur Beziehung zwischen SQL_ATTR_CURSOR_SENSITIVITY und den anderen Cursorattributen finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Ein SQLULEN-Wert, der den Cursortyp angibt:<br /><br /> SQL_CURSOR_FORWARD_ONLY = Der Cursor scrollt nur vorwärts.<br /><br /> SQL_CURSOR_STATIC = Die Daten im Resultset sind statisch.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = Der Treiber speichert und verwendet die Schlüssel für die Anzahl der Zeilen, die im Attribut SQL_ATTR_KEYSET_SIZE-Anweisung angegeben sind.<br /><br /> SQL_CURSOR_DYNAMIC = Der Treiber speichert und verwendet nur die Schlüssel für die Zeilen im Rowset.<br /><br /> Der Standardwert ist SQL_CURSOR_FORWARD_ONLY. Dieses Attribut kann nicht angegeben werden, nachdem die SQL-Anweisung vorbereitet wurde.<br /><br /> Wenn der angegebene Cursortyp von der Datenquelle nicht unterstützt wird, ersetzt der Treiber einen anderen Cursortyp und gibt SQLSTATE 01S02 zurück (Optionswert geändert). Bei einem gemischten oder dynamischen Cursor ersetzt der Treiber in der Reihenfolge einen Keyset-gesteuerten oder statischen Cursor. Bei einem Keyset-gesteuerten Cursor ersetzt der Treiber einen statischen Cursor.<br /><br /> Weitere Informationen zu scrollbaren Cursortypen finden Sie unter [Scrollbare Cursortypen](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Weitere Informationen zur Beziehung zwischen SQL_ATTR_CURSOR_TYPE und den anderen Cursorattributen finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob die automatische Auffüllung der IPD ausgeführt wird:<br /><br /> SQL_TRUE = Aktiviert die automatische Auffüllung der IPD nach einem Aufruf von **SQLPrepare**. SQL_FALSE = Deaktiviert die automatische Auffüllung der IPD nach einem Aufruf von **SQLPrepare**. (Eine Anwendung kann weiterhin IPD-Feldinformationen abrufen, indem **sie SQLDescribeParam**aufruft, sofern unterstützt.) Der Standardwert des Anweisungsattributs SQL_ATTR_ENABLE_AUTO_IPD ist SQL_FALSE. Weitere Informationen finden Sie unter [Automatische Auffüllung der IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Ein SQLLEN, \* das auf einen binären Lesezeichenwert verweist. Wenn **SQLFetchScroll** mit *fFetchOrientation* aufgerufen wird, der SQL_FETCH_BOOKMARK entspricht, nimmt der Treiber den Lesezeichenwert aus diesem Feld auf. Dieses Feld wird standardmäßig auf einen Nullzeiger gesetzt. Weitere Informationen finden Sie unter [Scrollen nach Lesezeichen](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Der Wert, auf den in diesem Feld verwiesen wird, wird nicht zum Löschen nach Lesezeichen, zur Aktualisierung nach Lesezeichen oder zum Abrufen nach Lesezeichenvorgängen in **SQLBulkOperations**verwendet, die Lesezeichen verwenden, die in Rowset-Puffern zwischengespeichert werden.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Das Handle für die IPD. Der Wert dieses Attributs ist der Deskriptor, der beim ersten Zuweisen der Anweisung zugewiesen wurde. Die Anwendung kann dieses Attribut nicht festlegen.<br /><br /> Dieses Attribut kann durch einen Aufruf von **SQLGetStmtAttr** abgerufen, aber nicht durch einen Aufruf von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Das Handle zum IRD. Der Wert dieses Attributs ist der Deskriptor, der beim ersten Zuweisen der Anweisung zugewiesen wurde. Die Anwendung kann dieses Attribut nicht festlegen.<br /><br /> Dieses Attribut kann durch einen Aufruf von **SQLGetStmtAttr** abgerufen, aber nicht durch einen Aufruf von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Ein SQLULEN, das die Anzahl der Zeilen im Keyset für einen Keyset-gesteuerten Cursor angibt. Wenn die Größe des Keysets 0 ist (Standardeinstellung), ist der Cursor vollständig keyset-gesteuert. Wenn die Keysetgröße größer als 0 ist, wird der Cursor gemischt (Keyset-gesteuert innerhalb des Keysets und dynamisch außerhalb des Keysets). Die Standardgröße des Keysets ist 0. Weitere Informationen zu Keyset-gesteuerten Cursorn finden Sie unter [Keyset-Driven Cursors](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Wenn die angegebene Größe die maximale Keysetgröße überschreitet, ersetzt der Treiber diese Größe und gibt SQLSTATE 01S02 zurück (Optionswert geändert).<br /><br /> **SQLFetch** oder **SQLFetchScroll** gibt einen Fehler zurück, wenn die Keysetgröße größer als 0 und kleiner als die Rowsetgröße ist.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Ein SQLULEN-Wert, der die maximale Datenmenge angibt, die der Treiber von einem Zeichen oder einer Binärspalte zurückgibt. Wenn *ValuePtr* kleiner als die Länge der verfügbaren Daten ist, werden die Daten von **SQLFetch** oder **SQLGetData** abgeschnitten und SQL_SUCCESS zurückgegeben. Wenn *ValuePtr* 0 ist (Standard), versucht der Treiber, alle verfügbaren Daten zurückzugeben.<br /><br /> Wenn die angegebene Länge kleiner als die minimale Datenmenge ist, die die Datenquelle zurückgeben kann, oder größer als die maximale Datenmenge, die die Datenquelle zurückgeben kann, ersetzt der Treiber diesen Wert und gibt SQLSTATE 01S02 zurück (Optionswert geändert).<br /><br /> Der Wert dieses Attributs kann auf einem geöffneten Cursor festgelegt werden. Die Einstellung wird jedoch möglicherweise nicht sofort wirksam, in diesem Fall gibt der Treiber SQLSTATE 01S02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.<br /><br /> Dieses Attribut soll den Netzwerkverkehr reduzieren und sollte nur unterstützt werden, wenn die Datenquelle (im Gegensatz zum Treiber) in einem mehrstufigen Treiber ihn implementieren kann. Dieser Mechanismus sollte nicht von Anwendungen verwendet werden, um Daten zu abschneiden. Um empfangene Daten zu abschneiden, sollte eine Anwendung die maximale Pufferlänge im *BufferLength-Argument* in **SQLBindCol** oder **SQLGetData**angeben.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Ein SQLULEN-Wert, der der maximalen Anzahl von Zeilen entspricht, die für eine **SELECT-Anweisung** an die Anwendung zurückgegeben werden sollen. Wenn \* *ValuePtr* gleich 0 ist (Standardeinstellung), gibt der Treiber alle Zeilen zurück.<br /><br /> Dieses Attribut soll den Netzwerkverkehr reduzieren. Konzeptionell wird es angewendet, wenn das Resultset erstellt wird, und das Resultset auf die ersten *ValuePtr-Zeilen* beschränkt. Wenn die Anzahl der Zeilen im Resultset größer als *ValuePtr*ist, wird das Resultset abgeschnitten.<br /><br /> SQL_ATTR_MAX_ROWS gilt für alle Resultsets in der *Anweisung*, einschließlich der von Katalogfunktionen zurückgegebenen. SQL_ATTR_MAX_ROWS legt ein Maximum für den Wert der Cursorzeilenanzahl fest.<br /><br /> Ein Treiber sollte SQL_ATTR_MAX_ROWS Verhalten für **SQLFetch** oder **SQLFetchScroll** nicht emulieren (wenn Die Größenbeschränkungen des Ergebnissatzes in der Datenquelle nicht implementiert werden können), wenn er nicht garantieren kann, dass SQL_ATTR_MAX_ROWS ordnungsgemäß implementiert wird.<br /><br /> Es ist treiberdefiniert, ob SQL_ATTR_MAX_ROWS für andere Anweisungen als SELECT-Anweisungen (z. B. Katalogfunktionen) gilt.<br /><br /> Der Wert dieses Attributs kann auf einem geöffneten Cursor festgelegt werden. Die Einstellung wird jedoch möglicherweise nicht sofort wirksam, in diesem Fall gibt der Treiber SQLSTATE 01S02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Ein SQLULEN-Wert, der bestimmt, wie die Zeichenfolgenargumente von Katalogfunktionen behandelt werden.<br /><br /> Wenn SQL_TRUE, wird das Zeichenfolgenargument von Katalogfunktionen als Bezeichner behandelt. Der Fall ist nicht von Bedeutung. Bei nicht getrennten Zeichenfolgen entfernt der Treiber alle nachgestellten Leerzeichen, und die Zeichenfolge wird in Großbuchstaben gefaltet. Bei abgegrenzten Zeichenfolgen entfernt der Treiber alle führenden oder nachfolgenden Leerzeichen und nimmt das, was sich zwischen den Trennzeichen befindet, wörtlich. Wenn eines dieser Argumente auf einen Nullzeiger festgelegt ist, gibt die Funktion SQL_ERROR und SQLSTATE HY009 (Ungültige Verwendung von NULL-Zeiger) zurück.<br /><br /> Wenn SQL_FALSE, werden die Zeichenfolgenargumente von Katalogfunktionen nicht als Bezeichner behandelt. Der Fall ist von Bedeutung. Sie können je nach Argument entweder ein Zeichenfolgensuchmuster enthalten oder nicht.<br /><br /> Der Standardwert ist SQL_FALSE.<br /><br /> Das *TableType-Argument* von **SQLTables**, das eine Liste von Werten enthält, ist von diesem Attribut nicht betroffen.<br /><br /> SQL_ATTR_METADATA_ID kann auch auf der Verbindungsebene eingestellt werden. (Es und SQL_ATTR_ASYNC_ENABLE sind die einzigen Anweisungsattribute, die auch Verbindungsattribute sind.)<br /><br /> Weitere Informationen finden Sie unter [Argumente in Katalogfunktionen](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob der Treiber SQL-Zeichenfolgen nach Escapesequenzen scannen soll:<br /><br /> SQL_NOSCAN_OFF = Der Treiber scannt SQL-Zeichenfolgen nach Escapesequenzen (Standard).<br /><br /> SQL_NOSCAN_ON = Der Treiber scannt SQL-Zeichenfolgen nicht nach Escapesequenzen. Stattdessen sendet der Treiber die Anweisung direkt an die Datenquelle.<br /><br /> Weitere Informationen finden Sie [unter Escape-Sequenzen in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN *-Wert, der auf einen Offset verweist, der Zeigern hinzugefügt wird, um die Bindung dynamischer Parameter zu ändern. Wenn dieses Feld ungleich NULL ist, verweist der Treiber auf den Zeiger, fügt den dereferenzierten Wert zu jedem der zurückgestellten Felder im Deskriptordatensatz hinzu (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) und verwendet die neuen Zeigerwerte bei der Bindung. Standardmäßig wird sie auf null gesetzt.<br /><br /> Der Bindungsoffset wird immer direkt zu den Feldern SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR hinzugefügt. Wenn der Offset in einen anderen Wert geändert wird, wird der neue Wert weiterhin direkt zum Wert im Deskriptorfeld hinzugefügt. Der neue Offset wird nicht zum Feldwert plus früheren Offsets hinzugefügt.<br /><br /> Weitere Informationen finden Sie unter [Parameterbindungsversätze](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_BIND_OFFSET_PTR Feld im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Ein SQLULEN-Wert, der die Bindungsausrichtung angibt, die für dynamische Parameter verwendet werden soll.<br /><br /> Dieses Feld ist auf SQL_PARAM_BIND_BY_COLUMN (Standard) festgelegt, um die spaltenweise Bindung auszuwählen.<br /><br /> Um die zeilenweise Bindung auszuwählen, wird dieses Feld auf die Länge der Struktur oder eine Instanz eines Puffers festgelegt, die an eine Reihe dynamischer Parameter gebunden ist. Diese Länge muss Platz für alle gebundenen Parameter und alle Auffüllungen der Struktur oder des Puffers enthalten, um sicherzustellen, dass das Ergebnis auf den Anfang desselben Parameters im nächsten Parametersatz darauf hinzweit, wenn die Adresse eines gebundenen Parameters mit der angegebenen Länge erhöht wird. Bei Verwendung *des Operators "Sizeof"* in ANSI C ist dieses Verhalten garantiert.<br /><br /> Weitere Informationen finden Sie unter [Binden von Arrays von Parametern](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das Feld SQL_DESC_ BIND_TYPE im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT-Wert, \* der auf ein Array von SQLUSMALLINT-Werten verweist, die verwendet werden, um einen Parameter während der Ausführung einer SQL-Anweisung zu ignorieren. Jeder Wert wird entweder auf SQL_PARAM_PROCEED (für den auszuführenden Parameter) oder auf SQL_PARAM_IGNORE (für den zu ignorierenden Parameter) festgelegt.<br /><br /> Ein Satz von Parametern kann während der Verarbeitung ignoriert werden, indem der Statuswert im Array festgelegt wird, auf den SQL_DESC_ARRAY_STATUS_PTR in der APD auf SQL_PARAM_IGNORE. Ein Satz von Parametern wird verarbeitet, wenn der Statuswert auf SQL_PARAM_PROCEED festgelegt ist oder wenn keine Elemente im Array festgelegt sind.<br /><br /> Dieses Anweisungsattribut kann auf einen Nullzeiger festgelegt werden, in diesem Fall gibt der Treiber keine Parameterstatuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst beim nächsten Aufruf von **SQLExecDirect** oder **SQLExecute** verwendet.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundener Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Arrays von Parametern](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT-Wert, \* der auf ein Array von SQLUSMALLINT-Werten verweist, die Statusinformationen für jede Zeile von Parameterwerten nach einem Aufruf von **SQLExecute** oder **SQLExecDirect**enthalten. Dieses Feld ist nur erforderlich, wenn PARAMSET_SIZE größer als 1 ist.<br /><br /> Die Statuswerte können die folgenden Werte enthalten:<br /><br /> SQL_PARAM_SUCCESS: Die SQL-Anweisung wurde für diesen Satz von Parametern erfolgreich ausgeführt.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Die SQL-Anweisung wurde für diesen Satz von Parametern erfolgreich ausgeführt. In der Diagnosedatenstruktur sind jedoch Warninformationen verfügbar.<br /><br /> SQL_PARAM_ERROR: Bei der Verarbeitung dieses Parameterssatzes ist ein Fehler aufgetreten. Zusätzliche Fehlerinformationen finden Sie in der Diagnosedatenstruktur.<br /><br /> SQL_PARAM_UNUSED: Dieser Parametersatz wurde nicht verwendet, möglicherweise aufgrund der Tatsache, dass ein vorheriger Parametersatz einen Fehler verursachte, der die weitere Verarbeitung abbrach, oder weil SQL_PARAM_IGNORE für diesen Satz von Parametern im Array festgelegt wurde, das vom SQL_ATTR_PARAM_OPERATION_PTR angegeben wurde.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Der Treiber behandelt Arrays von Parametern als monolithische Einheit und generiert daher diese Fehlerstufe nicht.<br /><br /> Dieses Anweisungsattribut kann auf einen Nullzeiger festgelegt werden, in diesem Fall gibt der Treiber keine Parameterstatuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst beim nächsten Aufruf von **SQLExecute** oder **SQLExecDirect** verwendet. Beachten Sie, dass das Festlegen dieses Attributs das vom Treiber implementierte Verhalten der Ausgabeparameter beeinflussen kann.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Arrays von Parametern](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im IPD-Header festgelegt.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Ein SQLULEN-Datensatzfeld, \* das auf einen Puffer verweist, in dem die Anzahl der verarbeiteten Parametersätze zurückgegeben werden soll, einschließlich Fehlersätzen. Keine Zahl wird zurückgegeben, wenn es sich um einen Nullzeiger handelt.<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ROWS_PROCESSED_PTR Feld im IPD-Header festgelegt.<br /><br /> Wenn der Aufruf von **SQLExecDirect** oder **SQLExecute,** der den Puffer ausfüllt, auf den durch dieses Attribut verwiesen wird, nicht SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, ist der Inhalt des Puffers nicht definiert.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Arrays von Parametern](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Ein SQLULEN-Wert, der die Anzahl der Werte für jeden Parameter angibt. Wenn SQL_ATTR_PARAMSET_SIZE größer als 1 ist, verweisen SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR der APD auf Arrays. Die Kardinalität jedes Arrays ist gleich dem Wert dieses Felds.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundener Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Arrays von Parametern](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_SIZE Feld im APD-Header festgelegt.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Ein SQLULEN-Wert, der der Anzahl der Sekunden entspricht, die gewartet werden müssen, bis eine SQL-Anweisung ausgeführt wird, bevor zur Anwendung zurückgesendet wird. Wenn *ValuePtr* gleich 0 (Standard) ist, gibt es kein Timeout.<br /><br /> Wenn das angegebene Timeout das maximale Timeout in der Datenquelle überschreitet oder kleiner als das minimale Timeout ist, ersetzt **SQLSetStmtAttr** diesen Wert und gibt SQLSTATE 01S02 zurück (Optionswert geändert).<br /><br /> Beachten Sie, dass die Anwendung **SQLCloseCursor** nicht aufrufen muss, um die Anweisung wiederzuverwenden, wenn eine **SELECT-Anweisung** ein Timeout vorliegt.<br /><br /> Das in diesem Anweisungsattribut festgelegte Abfragetimeout ist sowohl im synchronen als auch im asynchronen Modus gültig.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Ein SQLULEN-Wert:<br /><br /> SQL_RD_ON = **SQLFetchScroll** und, in ODBC *3.x*, **SQLFetch** Daten abrufen, nachdem er den Cursor an der angegebenen Position positioniert. Dies ist die Standardoption.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** und in ODBC *3.x* **ruft SQLFetch** keine Daten ab, nachdem der Cursor positioniert wurde.<br /><br /> Durch Festlegen SQL_RETRIEVE_DATA auf SQL_RD_OFF kann eine Anwendung überprüfen, ob eine Zeile vorhanden ist, oder eine Textmarke für die Zeile abrufen, ohne den Aufwand für das Abrufen von Zeilen zu verursachen. Weitere Informationen finden Sie unter [Scrollen und Abrufen von Zeilen](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Der Wert dieses Attributs kann auf einem geöffneten Cursor festgelegt werden. Die Einstellung wird jedoch möglicherweise nicht sofort wirksam, in diesem Fall gibt der Treiber SQLSTATE 01S02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Ein SQLULEN-Wert, der die Anzahl der Zeilen angibt, die von jedem Aufruf von **SQLFetch** oder **SQLFetchScroll**zurückgegeben werden. Es ist auch die Anzahl der Zeilen in einem Lesezeichen-Array, das in einem Massen-Lesezeichenvorgang in **SQLBulkOperations**verwendet wird. Der Standardwert ist 1.<br /><br /> Wenn die angegebene Rowsetgröße die maximale Rowsetgröße überschreitet, die von der Datenquelle unterstützt wird, ersetzt der Treiber diesen Wert und gibt SQLSTATE 01S02 zurück (Optionswert geändert).<br /><br /> Weitere Informationen finden Sie unter [Rowset-Größe](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_SIZE Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN *-Wert, der auf einen Offset verweist, der Zeigern hinzugefügt wird, um die Bindung von Spaltendaten zu ändern. Wenn dieses Feld ungleich NULL ist, verweist der Treiber auf den Zeiger, fügt den dereferenzierten Wert zu jedem der zurückgestellten Felder im Deskriptordatensatz hinzu (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) und verwendet die neuen Zeigerwerte bei der Bindung. Standardmäßig wird sie auf null gesetzt.<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_BIND_OFFSET_PTR Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Ein SQLULEN-Wert, der die Bindungsausrichtung festlegt, die verwendet werden soll, wenn **SQLFetch** oder **SQLFetchScroll** für die zugeordnete Anweisung aufgerufen wird. Die spaltenweise Bindung wird ausgewählt, indem der Wert auf SQL_BIND_BY_COLUMN gesetzt wird. Die Zeilen-weise Bindung wird ausgewählt, indem der Wert auf die Länge einer Struktur oder einer Instanz eines Puffers gesetzt wird, an den Ergebnisspalten gebunden werden.<br /><br /> Wenn eine Länge angegeben ist, muss sie Platz für alle gebundenen Spalten und alle Auffüllungen der Struktur oder des Puffers enthalten, um sicherzustellen, dass das Ergebnis auf den Anfang derselben Spalte in der nächsten Zeile zeigen, wenn die Adresse einer gebundenen Spalte mit der angegebenen Länge erhöht wird. Bei Verwendung der **Größe des** Operators mit Strukturen oder Unions in ANSI C ist dieses Verhalten garantiert.<br /><br /> Spaltenweise Bindung ist die Standardbindungsausrichtung für **SQLFetch** und **SQLFetchScroll**.<br /><br /> Weitere Informationen finden Sie unter [Bindungsspalten zur Verwendung mit Blockcursors](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_BIND_TYPE Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Ein SQLULEN-Wert, der die Nummer der aktuellen Zeile im gesamten Resultset ist. Wenn die Nummer der aktuellen Zeile nicht bestimmt werden kann oder keine aktuelle Zeile vorhanden ist, gibt der Treiber 0 zurück.<br /><br /> Dieses Attribut kann durch einen Aufruf von **SQLGetStmtAttr** abgerufen, aber nicht durch einen Aufruf von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT-Wert, \* der auf ein Array von SQLUSMALLINT-Werten verweist, die verwendet werden, um eine Zeile während eines Massenvorgangs mit **SQLSetPos**zu ignorieren. Jeder Wert wird entweder auf SQL_ROW_PROCEED (für die Zeile, die in den Massenvorgang einbezogen werden soll) oder auf SQL_ROW_IGNORE (für die Zeile, die vom Massenvorgang ausgeschlossen werden soll) festgelegt. (Zeilen können nicht ignoriert werden, wenn dieses Array während aufrufen von **SQLBulkOperations**verwendet wird.)<br /><br /> Dieses Anweisungsattribut kann auf einen Nullzeiger festgelegt werden, in diesem Fall gibt der Treiber keine Zeilenstatuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst beim nächsten Aufruf von **SQLSetPos** verwendet.<br /><br /> Weitere Informationen finden Sie unter [Aktualisieren von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) und Löschen von Zeilen im [Rowset mit SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld in der ARD festgelegt.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT-Wert, \* der auf ein Array von SQLUSMALLINT-Werten verweist, die Zeilenstatuswerte nach einem Aufruf von **SQLFetch** oder **SQLFetchScroll**enthalten. Das Array hat so viele Elemente wie Zeilen im Rowset.<br /><br /> Dieses Anweisungsattribut kann auf einen Nullzeiger festgelegt werden, in diesem Fall gibt der Treiber keine Zeilenstatuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst beim nächsten Aufruf von **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**oder **SQLSetPos** verwendet.<br /><br /> Weitere Informationen finden Sie unter [Anzahl der abgerufenen Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im IRD-Header festgelegt.<br /><br /> Dieses Attribut wird von einem ODBC *2.x-Treiber* dem *array rgbRowStatus* in einem Aufruf von **SQLExtendedFetch**zugeordnet.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Ein SQLULEN-Wert, \* der auf einen Puffer verweist, in dem die Anzahl der Zeilen zurückgegeben wird, die nach einem Aufruf von **SQLFetch** oder **SQLFetchScroll**abgerufen wurden. die Anzahl der Zeilen, die von einem Massenvorgang betroffen sind, der von einem Aufruf von **SQLSetPos** mit dem *Operation-Argument* SQL_REFRESH ausgeführt wird. oder die Anzahl der Zeilen, die von einem Massenvorgang betroffen sind, der von **SQLBulkOperations**ausgeführt wird. Diese Zahl enthält Fehlerzeilen.<br /><br /> Weitere Informationen finden Sie unter [Anzahl der abgerufenen Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Anweisungsattributs wird das SQL_DESC_ROWS_PROCESSED_PTR Feld im IRD-Header festgelegt.<br /><br /> Wenn der Aufruf von **SQLFetch** oder **SQLFetchScroll,** der den Puffer ausfüllt, auf den durch dieses Attribut verwiesen wird, nicht SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, ist der Inhalt des Puffers nicht definiert.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob Treiber, die positionierte Aktualisierungs- und Löschanweisungen simulieren, garantieren, dass solche Anweisungen nur eine einzelne Zeile betreffen.<br /><br /> Um positionierte Aktualisierungs- und Löschanweisungen zu simulieren, erstellen die meisten Treiber eine durchsuchte **UPDATE-** oder **DELETE-Anweisung,** die eine **WHERE-Klausel** enthält, die den Wert jeder Spalte in der aktuellen Zeile angibt. Sofern diese Spalten keinen eindeutigen Schlüssel bilden, kann sich eine solche Anweisung auf mehrere Zeilen auswirken.<br /><br /> Um sicherzustellen, dass solche Anweisungen nur eine Zeile betreffen, bestimmt der Treiber die Spalten in einem eindeutigen Schlüssel und fügt diese Spalten dem Resultset hinzu. Wenn eine Anwendung garantiert, dass die Spalten im Ergebnissatz einen eindeutigen Schlüssel bilden, ist der Treiber dazu nicht erforderlich. Dies kann die Ausführungszeit verkürzen.<br /><br /> SQL_SC_NON_UNIQUE = Der Treiber garantiert nicht, dass simulierte positionierte Aktualisierungs- oder Löschanweisungen nur eine Zeile betreffen. es liegt in der Verantwortung der Anwendung, dies zu tun. Wenn eine Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute**, **SQLExecDirect**oder **SQLSetPos** SQLSTATE 01001 (Cursor-Vorgangskonflikt) zurück.<br /><br /> SQL_SC_TRY_UNIQUE = Der Treiber versucht sicherzustellen, dass simulierte positionierte Aktualisierungs- oder Löschanweisungen nur eine Zeile betreffen. Der Treiber führt solche Anweisungen immer aus, auch wenn sie mehr als eine Zeile betreffen können, z. B. wenn kein eindeutiger Schlüssel vorhanden ist. Wenn eine Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute**, **SQLExecDirect**oder **SQLSetPos** SQLSTATE 01001 (Cursor-Vorgangskonflikt) zurück.<br /><br /> SQL_SC_UNIQUE = Der Treiber garantiert, dass simulierte positionierte Aktualisierungs- oder Löschanweisungen nur eine Zeile betreffen. Wenn der Treiber dies für eine bestimmte Anweisung nicht garantieren kann, gibt **SQLExecDirect** oder **SQLPrepare** einen Fehler zurück.<br /><br /> Wenn die Datenquelle systemeigene SQL-Unterstützung für positionierte Aktualisierungs- und Löschanweisungen bereitstellt und der Treiber keine Cursor simuliert, wird SQL_SUCCESS zurückgegeben, wenn SQL_SC_UNIQUE für SQL_SIMULATE_CURSOR angefordert wird. SQL_SUCCESS_WITH_INFO wird zurückgegeben, wenn SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE angefordert wird. Wenn die Datenquelle die SQL_SC_TRY_UNIQUE Supportebene bereitstellt und der Treiber dies nicht tut, wird SQL_SUCCESS für SQL_SC_TRY_UNIQUE zurückgegeben, und SQL_SUCCESS_WITH_INFO wird für SQL_SC_NON_UNIQUE zurückgegeben.<br /><br /> Wenn der angegebene Cursorsimulationstyp von der Datenquelle nicht unterstützt wird, ersetzt der Treiber einen anderen Simulationstyp und gibt SQLSTATE 01S02 zurück (Optionswert geändert). Bei SQL_SC_UNIQUE ersetzt der Fahrer in der Reihenfolge SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE. Für SQL_SC_TRY_UNIQUE ersetzt der Fahrer SQL_SC_NON_UNIQUE.<br /><br /> Der Standardwert ist SQL_SC_UNIQUE.<br /><br /> Weitere Informationen finden Sie unter [Simulieren von positionierten Aktualisierungs- und Löschanweisungen](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob eine Anwendung Lesezeichen mit einem Cursor verwendet:<br /><br /> SQL_UB_OFF = Aus (Standard)<br /><br /> SQL_UB_VARIABLE = Eine Anwendung verwendet Lesezeichen mit einem Cursor, und der Treiber stellt Lesezeichen variabler Länge bereit, wenn sie unterstützt werden. SQL_UB_FIXED ist in ODBC *3.x*veraltet. ODBC *3.x-Anwendungen* sollten Lesezeichen mit variabler Länge immer verwenden, auch wenn sie mit ODBC *2.x-Treibern* arbeiten (die nur 4-Byte-Lesezeichen mit fester Länge unterstützten). Dies liegt daran, dass eine Lesezeichen mit fester Länge nur ein Sonderfall einer Lesezeichen variabler Länge ist. Wenn Sie mit einem ODBC *2.x-Treiber* arbeiten, ordnet der Treiber-Manager SQL_UB_VARIABLE SQL_UB_FIXED zu.<br /><br /> Um Lesezeichen mit einem Cursor zu verwenden, muss die Anwendung dieses Attribut mit dem SQL_UB_VARIABLE Wert angeben, bevor Sie den Cursor öffnen.<br /><br /> Weitere Informationen finden Sie unter [Abrufen von Lesezeichen](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Diese Funktionen können nur dann asynchron aufgerufen werden, wenn der Deskriptor ein Implementierungsdeskriptor und kein Anwendungsdeskriptor ist.  
  
 Siehe [Column-Wise Binding](../../../odbc/reference/develop-app/column-wise-binding.md) und [Row-Wise Binding](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Verwandte Funktionen  
  
|Informationen über|Finden Sie unter|  
|---------------------------|---------|  
|Abbrechen der Anweisungsverarbeitung|[SQLCancel-Funktion](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Zurückgeben der Einstellung eines Verbindungsattributs|[SQLGetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Zurückgeben der Einstellung eines Anweisungsattributs|[SQLGetStmtAttr-Funktion](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Festlegen eines Verbindungsattributs|[SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Festlegen eines einzelnen Feldes des Deskriptors|[SQLSetDescField-Funktion](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Weitere Informationen  
 [ODBC-API-Referenz](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [ODBC-Headerdateien](../../../odbc/reference/install/odbc-header-files.md)
