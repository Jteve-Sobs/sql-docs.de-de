---
title: SQLSetStmtAttr-Funktion | Microsoft-Dokumentation
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 0805cafcdae76e3f4d7f8405088f5fe93fbc985b
ms.sourcegitcommit: 56b963446965f3a4bb0fa1446f49578dbff382e0
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/11/2019
ms.locfileid: "67793911"
---
# <a name="sqlsetstmtattr-function"></a>SQLSetStmtAttr-Funktion
**Übereinstimmung mit Standards**  
 Eingeführt in Version: ODBC 3.0 Standards Compliance: ISO 92  
  
 **Zusammenfassung**  
 **SQLSetStmtAttr** Attribute, die im Zusammenhang mit einer Anweisung festgelegt.  
  
> [!NOTE]
>  Weitere Informationen dazu, was der Treiber-Manager diese Funktion auf, wenn eine ODBC zuordnet *3.x* mit einer ODBC-Anwendung funktioniert *2.x* -Treiber verwenden, finden Sie unter [Zuordnen von Ersatzfunktionen für rückwärts Kompatibilität von Anwendungen](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntax  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumente  
 *StatementHandle*  
 [Eingabe] Anweisungshandle.  
  
 *Attribut*  
 [Eingabe] Option, um festzulegen, aufgeführt in "Kommentare".  
  
 *ValuePtr*  
 [Eingabe] Wert zugeordnet werden *Attribut*. Abhängig vom Wert *Attribut*, *ValuePtr* wird einer der folgenden sein:  
  
-   Ein Handle für den ODBC-Deskriptor.  
  
-   Eine SQLUINTEGER-Wert.  
  
-   Ein Wert SQLULEN erstellt wurde.  
  
-   Ein Zeiger auf eine der folgenden:  
  
    -   Eine Null-terminierte Zeichenfolge.  
  
    -   Ein binärer Puffer.  
  
    -   Ein Wert oder ein Array vom Typ SQLLEN SQLULEN erstellt wurde oder SQLUSMALLINT.  
  
    -   Ein Treiber definierter Wert.  
  
 Wenn die *Attribut* Argument ist ein Wert treiberspezifische *ValuePtr* möglicherweise eine Ganzzahl mit Vorzeichen.  
  
 *StringLength*  
 [Eingabe] Wenn *Attribut* ist ein ODBC-definierten Attribut und *ValuePtr* zeigt auf eine Zeichenfolge oder ein binärer Puffer, in dieses Argument muss die Länge des \* *ValuePtr*. Wenn *Attribut* ist ein ODBC-definierten Attribut und *ValuePtr* ist eine ganze Zahl, *StringLength* wird ignoriert.  
  
 Wenn *Attribut* ein treiberdefinierten-Attribut, wird die Anwendung zeigt die Art des Attributs auf den Treiber-Manager an, indem die *StringLength* Argument. *StringLength* können die folgenden Werte aufweisen:  
  
-   Wenn *ValuePtr* ist ein Zeiger auf eine Zeichenfolge, *StringLength* ist die Länge der Zeichenfolge oder SQL_NTS.  
  
-   Wenn *ValuePtr* ist ein Zeiger auf ein binärer Puffer, aus, und klicken Sie dann die Anwendung das Ergebnis der SQL_LEN_BINARY_ATTR platziert (*Länge*)-Makro in *StringLength*. Dadurch wird einen negativen Wert im platziert *StringLength*.  
  
-   Wenn *ValuePtr* ist ein Zeiger auf einen anderen Wert als eine Zeichenfolge oder eine binäre Zeichenfolge *StringLength* Wert SQL_IS_POINTER haben sollte.  
  
-   Wenn *ValuePtr* enthält einen Wert fester Länge *StringLength* ist SQL_IS_INTEGER oder SQL_IS_UINTEGER, nach Bedarf.  
  
## <a name="returns"></a>Rückgabewert  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, or SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnose  
 Wenn **SQLSetStmtAttr** gibt SQL_ERROR oder SQL_SUCCESS_WITH_INFO zurück, die einen zugeordneten SQLSTATE-Wert abgerufen werden können, durch den Aufruf **SQLGetDiagRec** mit einem *HandleType* SQL _HANDLE_STMT und *behandeln* von *StatementHandle*. Die folgende Tabelle enthält die SQLSTATE-Werten, die häufig vom **SQLSetStmtAttr** und erläutert, jeweils im Kontext dieser Funktion; die Notation "(DM)" vorangestellt ist, die Beschreibungen der SQLSTATEs, die vom Treiber-Manager zurückgegeben. Der Rückgabecode jeder SQLSTATE-Wert zugeordnet ist SQL_ERROR zurück, sofern nicht anders angegeben.  
  
|SQLSTATE|Fehler|Beschreibung|  
|--------------|-----------|-----------------|  
|01000|Allgemeine Warnung|Treiber-spezifische Meldung dient zu Informationszwecken. (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|01S02|Optionswert geändert|Der Treiber nicht den Wert im angegebenen *ValuePtr*, oder der Wert im angegebenen *ValuePtr* sind ungültig aufgrund von Arbeitsbedingungen Implementierung, damit der Treiber einen ähnlichen Wert ersetzt. (**SQLGetStmtAttr** aufgerufen werden, um vorübergehend ersetzten Werts zu ermitteln.) Der Ersatzwert ist gültig für die *StatementHandle* bis der Cursor geschlossen wird, an diesem Punkt das Anweisungsattribut setzt auf seinen ursprünglichen Wert. Die Anweisungsattribute, die geändert werden können, sind:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|08S01|Kommunikations-Verbindungsfehler|Die kommunikationsverbindung zwischen dem Treiber und der Datenquelle, die mit der der Treiber verbunden wurde, Fehler vor der Verarbeitung für die Funktion abgeschlossen.|  
|24000|Ungültiger Cursorstatus|Die *Attribut* war SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR oder SQL_ATTR_USE_BOOKMARKS und der Cursor geöffnet wurde.|  
|HY000|Allgemeiner Fehler.|Für die keine spezifischen SQLSTATE ist und für die keine implementierungsabhängige SQLSTATE definiert wurde, ist ein Fehler aufgetreten. Die zurückgegebene Fehlermeldung **SQLGetDiagRec** in die  *\*MessageText* Puffer beschreibt den Fehler und seine Ursache.|  
|HY001|Fehler bei der speicherbelegung|Der Treiber konnte nicht zur speicherbelegung, die zur Unterstützung der Ausführung oder den Abschluss der Funktion erforderlich sind.|  
|HY009|Ungültige Verwendung eines null-Zeiger|Die *Attribut* Argument identifiziert ein Anweisungsattribut, die eine String-Attribut, erforderlich und die *ValuePtr* Argument wurde ein null-Zeiger.|  
|HY010|Fehler in der Funktionsreihenfolge|(DM) eine asynchron ausgeführte Funktion wurde aufgerufen, der Verbindungshandles, die zugeordnet wird die *StatementHandle*. Dieser asynchrone Funktion war weiterhin ausgeführt, wenn die **SQLSetStmtAttr** Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, oder **SQLMoreResults** wurde aufgerufen, die *StatementHandle* und SQL_PARAM_DATA_ zurückgegeben VERFÜGBAR. Diese Funktion war aufgerufen, bevor Daten für alle Stream-Parameter abgerufen wurde.<br /><br /> (DM) eine asynchron ausgeführte Funktion wurde aufgerufen, die *StatementHandle* und wurde noch ausgeführt werden, wenn diese Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, oder **SQLSetPos** wurde aufgerufen, die *StatementHandle* und SQL_NEED_DATA zurückgegeben. Diese Funktion wurde aufgerufen, bevor die Daten für alle Data-at-Execution-Parameter oder Spalten gesendet wurden.|  
|HY011|Attribut kann jetzt nicht festgelegt werden|Die *Attribut* war SQL_ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR oder SQL_ ATTR_USE_BOOKMARKS und die Anweisung vorbereitet wurde.|  
|HY013|Fehler bei arbeitsspeicherverwaltung|Der Funktionsaufruf kann nicht verarbeitet werden, da die zugrunde liegenden Speicherobjekte, möglicherweise aufgrund von unzureichendem Speicher konnte nicht zugegriffen werden.|  
|HY017|Ungültige Verwendung von einer automatisch zugeordneten Deskriptorhandles|(DM) die *Attribut* Argument war SQL_ATTR_IMP_ROW_DESC oder SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) die *Attribut* Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC und der Wert in *ValuePtr* ursprünglich war ein implizit zugeordneten Deskriptorhandles als das Handle für die ARD oder APD zugeordnet ist.|  
|HY024|Ungültiger Attributwert|Berücksichtigung des angegebenen *Attribut* Wert in wurde ein ungültiger Wert angegeben *ValuePtr*. (Der Treiber-Manager gibt SQLSTATE nur für die Verbindung und Anweisungsattribute, die einen diskreten Satz von Werten, z. B. SQL_ATTR_ACCESS_MODE oder SQL_ ATTR_ASYNC_ENABLE zu akzeptieren. Für alle anderen Verbindung und Anweisungsattribute, die Treiber muss überprüfen Sie den Wert im angegebenen *ValuePtr*.)<br /><br /> Die *Attribut* Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und *ValuePtr* wurde ein explizit zugeordneten Deskriptorhandles, die nicht auf dieselbe Verbindung wie die  *StatementHandle* Argument.|  
|HY090|Ungültige Zeichenfolgen- oder Pufferlänge.|(DM)  *\*ValuePtr* ist eine Zeichenfolge, und die *StringLength* Argument war kleiner als 0, aber nicht SQL_NTS.|  
|HY092|Ungültiger Attribut-/Optionsbezeichner|(DM) der Wert für das Argument angegebene *Attribut* war nicht gültig für die Version von ODBC, die vom Treiber unterstützt werden.<br /><br /> (DM) der Wert für das Argument angegebene *Attribut* wurde eine nur-Lese Attribut.|  
|HY117|Verbindung wird aufgrund eines unbekannten Transaktionsstatus angehalten. Trennen Sie nur aus, und nur-Lese Funktionen sind zulässig.|(DM) finden Sie weitere Informationen zum angehaltenen Zustand, [SQLEndTran-Funktion](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Optionales Feature nicht implementiert.|Der angegebene Wert für das Argument *Attribut* wurde ein gültiger ODBC-Anweisungsattribut, für die ODBC-Version vom Treiber unterstützt werden, jedoch wurde vom Treiber nicht unterstützt.<br /><br /> Die *Attribut* Argument war SQL_ATTR_ASYNC_ENABLE und einem Aufruf von **SQLGetInfo** mit einer *Informationsart* SQL_ASYNC_MODE SQL_AM_CONNECTION zurückgibt.<br /><br /> Die *Attribut* Argument SQL_ATTR_ENABLE_AUTO_IPD, und der Wert des Verbindungsattributs SQL_ATTR_AUTO_IPD Betrug SQL_FALSE.|  
|HYT01|Das Verbindungstimeout ist abgelaufen|Das Verbindungstimeout ist abgelaufen, bevor die Datenquelle auf die Anforderung geantwortet hat. Das Verbindungstimeout festgelegt ist, über **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Diese Funktion wird vom Treiber nicht unterstützt werden.|(DM) der Treiber zugeordnet der *StatementHandle* die Funktion nicht unterstützt.|  
|S1118|Asynchrone Benachrichtigung unterstützt Treiber nicht.|Wenn der Aufruf **SQLSetStmtAttr** festzulegende SQL_ATTR_ASYNC_STMT_EVENT; asynchrone Benachrichtigung wird vom Treiber nicht unterstützt.|  
  
## <a name="comments"></a>Kommentare  
 Anweisungsattribute, die für eine Anweisung bleiben wirksam, bis sie durch einen anderen Aufruf geändert werden **SQLSetStmtAttr** oder bis die Anweisung, durch den Aufruf gelöscht wird **SQLFreeHandle**. Aufrufen von **SQLFreeStmt** mit SQL_CLOSE, SQL_UNBIND oder SQL_RESET_PARAMS Option setzt nicht Anweisungsattribute.  
  
 Einige Anweisungsattribute unterstützen Ersetzung von einen ähnlichen Wert aus, wenn die Datenquelle in angegebenen Wert nicht unterstützt *ValuePtr*. In solchen Fällen gibt der Treiber SQL_SUCCESS_WITH_INFO und SQLSTATE 01 s 02 (der Optionswert wurde geändert). Z. B. wenn *Attribut* ist SQL_ATTR_CONCURRENCY und *ValuePtr* SQL_CONCUR_ROWVER, und wenn die Datenquelle dies unterstützt, des Treibers ersetzt SQL_CONCUR_VALUES SQL_ zurückgibt SUCCESS_WITH_INFO. Um den Ersatzwert zu bestimmen, die eine Anwendung ruft **SQLGetStmtAttr**.  
  
 Legen Sie das Format der Daten mit *ValuePtr* hängt von der angegebenen *Attribut*. **SQLSetStmtAttr** Attributinformationen in einem von zwei verschiedenen Formaten akzeptiert: eine Zeichenfolge oder ein ganzzahliger Wert. Das Format der einzelnen wird in seine Beschreibung aufgeführt. Dieses Format anwendbar ist, die für jedes Attribut in zurückgegebenen Informationen **SQLGetStmtAttr**. Zeichenfolgen, verweist der *ValuePtr* Argument **SQLSetStmtAttr** haben eine Länge von *StringLength*.  
  
> [!NOTE]
>  Die Fähigkeit zum Festlegen von Anweisungsattribute auf der Verbindungsebene durch Aufrufen von **SQLSetConnectAttr** veraltet in ODBC *3.x*. ODBC *3.x* Anwendungen sollten auf der Verbindungsebene Anweisungsattribute festlegen. ODBC *3.x* Anweisungsattribute können nicht auf Verbindungsebene, mit Ausnahme von den SQL_ATTR_METADATA_ID und SQL_ATTR_ASYNC_ENABLE-Attributen, die sowohl-Verbindungsattributen und Anweisungsattribute und kann nicht festgelegt werden Legen Sie auf der Verbindungsebene oder Anweisungsebene.  
> 
> [!NOTE]
>  ODBC *3.x* -Treiber unterstützen müssen diese Funktion nur mit dem ODBC-Mitarbeiter sollten *2.x* Anwendungen, die ODBC festgelegt *2.x* Anweisungsoptionen auf Verbindungsebene. Weitere Informationen finden Sie unter "Einstellung Anweisung Optionen auf der Verbindungsebene" unter [SQLSetConnectOption-Zuordnung](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) in Anhang G: Treiber-Richtlinien für die Abwärtskompatibilität zu gewährleisten.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Anweisungsattribute, die von Deskriptorfelder festlegen  
 Viele Anweisungsattribute entsprechen einem Header-Feld einen Deskriptor. Diese Attribute festlegen tatsächlich Ergebnisse in der Einstellung der Sicherheitsbeschreibung Felder. Festlegen von Feldern durch einen Aufruf von **SQLSetStmtAttr** statt an **SQLSetDescField** hat den Vorteil, die ein Handle für die Sicherheitsbeschreibung nicht für den Funktionsaufruf abgerufen werden sollen.  
  
> [!CAUTION]  
>  Aufrufen von **SQLSetStmtAttr** für eine Anweisung auf andere Anweisungen auswirken kann. Dies tritt auf, wenn APD oder der Anweisung zugeordneten ARD explizit zugeordnet ist, und auch andere Anweisungen zugeordnet ist. Da **SQLSetStmtAttr** ändert das APD oder ARD, die Änderungen gelten für alle Anweisungen, die der dieser Deskriptor zugeordnet ist. Wenn dies nicht das erforderliche Verhalten ist, sollte die Anwendung Deskriptor dieser aus den anderen Anweisungen trennen (durch Aufrufen von **SQLSetStmtAttr** auf ein anderes Feld SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC fest Deskriptorhandles) vor dem Aufruf **SQLSetStmtAttr** erneut aus.  
  
 Wenn aufgrund der entsprechenden Anweisungsattribut festgelegt wird einem Beschreibungsfeld festgelegt ist, wird das Feld festgelegt, nur für die entsprechenden Deskriptoren, die derzeit zugeordnet, mit der Anweisung identifizierte sind die *StatementHandle* Argument und der attributeinstellung wirkt sich keine Deskriptoren, die diese Anweisung in der Zukunft zugeordnet sein können. Wenn einem Beschreibungsfeld, der auch ein Anweisungsattribut festgelegt wird, durch einen Aufruf von **SQLSetDescField**, das entsprechende Anweisungsattribut festgelegt ist. Wenn von einer Anweisung ein explizit zugewiesenen Deskriptor getrennt ist, wird eine Anweisung-Attributs, das ein Headerfeld entspricht, der Wert des Felds im implizit zugewiesene Deskriptor wiederhergestellt.  
  
 Wenn eine Anweisung zugeordnet ist (finden Sie unter [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), vier Deskriptorhandles automatisch zugeordnet und der Anweisung zugeordnet werden. Explizit zugewiesene Deskriptorhandles können durch Aufrufen der Anweisung zugeordnet werden **SQLAllocHandle** mit einer *fHandleType* von SQL_HANDLE_DESC einen Deskriptorhandle aufrufen und anschließend zuweisen **SQLSetStmtAttr** , die Anweisung die Deskriptorhandles zugeordnet werden soll.  
  
 Die Anweisungsattribute in der folgenden Tabelle entsprechen deskriptorheaderfelder.  
  
|Anweisungsattribut|Header-Feld|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Anweisungsattribute  
 Die aktuell definierten Attribute und die Version von ODBC in der sie eingeführt wurden, werden in der folgenden Tabelle angezeigt. Es wird erwartet, dass weitere Attribute von Treibern Nutzen aus verschiedenen Datenquellen definiert werden. ODBC ist eine Reihe von Attributen reserviert. Treiberentwickler müssen Werte für die eigene Verwendung treiberspezifische aus Open Group reservieren. Weitere Informationen finden Sie unter [treiberspezifische Datentypen, Deskriptortypen, Informationstypen, Diagnosetypen und Attribute](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|*ValuePtr* Inhalt|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Das Handle für die APD für nachfolgende Aufrufe **SQLExecute** und **SQLExecDirect** des Anweisungshandles. Der anfängliche Wert dieses Attributs ist der Deskriptor, der implizit zugeordnet werden, wenn die Anweisung ursprünglich zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle, das ursprünglich für den Deskriptor zugeordnet festgelegt ist, eine explizit zugewiesene APD-Handle, das zuvor das Anweisungshandle zugeordnet wurde aufgehoben wird, und das Anweisungshandle wird auf der implizit zugeordnet APD Handle.<br /><br /> Dieses Attribut kann nicht festgelegt werden, um ein Deskriptorhandle, das implizit für eine andere Anweisung zugewiesen wurde oder auf einem anderen Deskriptorhandle, das implizit in derselben Anweisung festgelegt wurde; implizit zugewiesene Deskriptorhandles darf nicht mehr als eine Anweisung oder Deskriptorhandles zugeordnet sein.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Das Handle für die ARD für nachfolgende Abrufe des Anweisungshandles. Der anfängliche Wert dieses Attributs ist der Deskriptor, der implizit zugeordnet werden, wenn die Anweisung ursprünglich zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle, das ursprünglich für den Deskriptor zugeordnet festgelegt ist, eine explizit zugewiesene ARD-Handle, das zuvor das Anweisungshandle zugeordnet wurde aufgehoben wird, und das Anweisungshandle wird auf der implizit zugeordnet ARD Handle.<br /><br /> Dieses Attribut kann nicht festgelegt werden, um ein Deskriptorhandle, das implizit für eine andere Anweisung zugewiesen wurde oder auf einem anderen Deskriptorhandle, das implizit in derselben Anweisung festgelegt wurde; implizit zugewiesene Deskriptorhandles darf nicht mehr als eine Anweisung oder Deskriptorhandles zugeordnet sein.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob eine Funktion aufgerufen wird, mit der angegebenen Anweisung asynchron ausgeführt wird:<br /><br /> SQL_ASYNC_ENABLE_OFF = Disable-Anweisung auf asynchrone Ausführung Support (Standard).<br /><br /> SQL_ASYNC_ENABLE_ON = Unterstützung von Ebene asynchrone Ausführung aktivieren.<br /><br /> Weitere Informationen finden Sie unter [asynchrone Ausführung (Methode abrufen)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Bei Treibern mit Unterstützung von Ebene asynchron ist das Anweisungsattribut SQL_ATTR_ASYNC_ENABLE schreibgeschützt. Der Wert ist identisch mit den Wert des Verbindungsattributs Ebene mit dem gleichen Namen zu dem Zeitpunkt, die das Anweisungshandle zugewiesen wurde.<br /><br /> Aufrufen von **SQLSetStmtAttr** um SQL_ATTR_ASYNC_ENABLE festzulegen, wenn die SQL_ASYNC_MODE *Informationsart* gibt SQL_AM_CONNECTION zurück SQLSTATE HYC00 (optionales Feature nicht implementiert). Weitere Informationen finden Sie unter [SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) für Weitere Informationen.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Ein SQLPOINTER-Wert, der ein Ereignishandle ist.<br /><br /> Benachrichtigung über den Abschluss von asynchronen Funktionen ist aktiviert, durch den Aufruf **SQLSetStmtAttr** Festlegen der **SQL_ATTR_ASYNC_STMT_EVENT** -Attributs angibt und das Ereignishandle.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Eine SQLPOINTER auf die asynchrone Rückruffunktion.<br /><br /> Nur der Treiber-Manager des Treibers aufrufen können **SQLSetStmtAttr** -Funktion mit diesem Attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Eine SQLPOINTER auf Context-Struktur<br /><br /> Nur der Treiber-Manager des Treibers aufrufen können **SQLSetStmtAttr** -Funktion mit diesem Attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, die Cursorparallelität:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor ist schreibgeschützt. Es sind keine Updates zulässig.<br /><br /> SQL_CONCUR_LOCK = Cursor verwendet die niedrigste Ebene von Sperren ausreichen, um sicherzustellen, dass die Zeile aktualisiert werden kann.<br /><br /> SQL_CONCUR_ROWVER = Cursor verwendet Steuerung durch vollständige Parallelität, Vergleichen von Zeilenversionen, z. B. SQLBase ROWID oder Sybase-TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor verwendet Steuerung durch vollständige Parallelität, Vergleichen von Werten.<br /><br /> Der Standardwert für SQL_ATTR_CONCURRENCY ist SQL_CONCUR_READ_ONLY.<br /><br /> Dieses Attribut kann nicht für einen geöffneten Cursor nicht angegeben werden. Weitere Informationen finden Sie unter [Parallelitätstypen](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Wenn die SQL_ATTR_CURSOR_TYPE *Attribut* geändert wird auf einen Typ, der den aktuellen Wert der SQL_ATTR_CONCURRENCY nicht unterstützt, wird der Wert der SQL_ATTR_CONCURRENCY auf der Ausführungszeit und eine Warnung ausgegeben, wenn geändertwerden**SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn der Treiber unterstützt die **SELECT FOR UPDATE** -Anweisung und eine solche Anweisung ausgeführt wird, während der Wert der SQL_ATTR_CONCURRENCY auf SQL_CONCUR_READ_ONLY festgelegt ist, wird ein Fehler zurückgegeben. Wenn der Wert der SQL_ATTR_CONCURRENCY auf einen Wert, die die Treiber für einen Wert von SQL_ATTR_CURSOR_TYPE jedoch nicht für den aktuellen Wert der SQL_ATTR_CURSOR_TYPE unterstützt geändert wird, wird der Wert der SQL_ATTR_CURSOR_TYPE Ausführungszeit und SQLSTATE 01 s 02 geändert werden (Der Optionswert wurde geändert) wird ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn die angegebene Parallelität von der Datenquelle nicht unterstützt wird, wird der Treiber ersetzt von einem anderen Parallelitätsmodell und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert). Für SQL_CONCUR_VALUES, ersetzt der Treiber SQL_CONCUR_ROWVER, und umgekehrt. Bei SQL_CONCUR_LOCK ersetzt der Treiber in der Reihenfolge, SQL_CONCUR_ROWVER oder SQL_CONCUR_VALUES. Die Gültigkeit des ersetzten Werts wird bis zur Ausführungszeit nicht überprüft werden.<br /><br /> Weitere Informationen zu die Beziehung zwischen SQL_ATTR_CONCURRENCY und die andere Cursorattribute, finden Sie unter [Cursoreigenschaften und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, das Maß an Unterstützung, die die Anwendung erforderlich sind. Dieses Attribut wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable-Cursor sind nicht erforderlich, über das Anweisungshandle. Wenn die Anwendung ruft **SQLFetchScroll** auf dieses Handle, der einzige gültige Wert von *FetchOrientation* ist SQL_FETCH_NEXT. Dies ist die Standardeinstellung.<br /><br /> SQL_SCROLLABLE = Scrollable-Cursor sind erforderlich, über das Anweisungshandle. Beim Aufrufen von **SQLFetchScroll**, geben Sie die Anwendung möglicherweise einen gültigen Wert der *FetchOrientation*, erreichen cursorpositionierung in anderen Modi als den sequenziellen Modus.<br /><br /> Weitere Informationen zu scrollfähige Cursor, finden Sie unter [scrollfähige Cursor](../../../odbc/reference/develop-app/scrollable-cursors.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SCROLLABLE und die andere Cursorattribute finden Sie unter [Cursoreigenschaften und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob der Cursor über das Anweisungshandle sichtbar zu machen legen Sie die Änderungen an der ein Ergebnis von einem anderen Cursor. Dieses Attribut wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute**. Eine Anwendung kann wieder Lesen der Wert dieses Attributs auf seinen ursprünglichen Zustand oder den Zustand wie die meisten vor kurzem erhalten von der Anwendung festgelegt.<br /><br /> SQL_UNSPECIFIED = es wird eine nicht angegeben, was ist, dass der Cursortyp und gibt an, ob der Cursor über das Anweisungshandle die Änderungen an einem Ergebnissatz durch einen anderen Cursor sichtbar. Cursor für das Anweisungshandle möglicherweise keine, einige oder alle diese Änderungen sichtbar. Dies ist die Standardeinstellung.<br /><br /> SQL_INSENSITIVE = alle Cursor auf die Anweisung Handle anzeigen, die das Resultset ohne spiegeln alle Änderungen durch einen anderen Cursor ausgeführt wird. INSENSITIVE-Cursor sind schreibgeschützt. Dies entspricht in einen statischen Cursor, der eine Parallelität, die verfügt schreibgeschützt ist.<br /><br /> SQL_SENSITIVE = alle Cursor auf die Anweisung Handle Stellen sichtbar alle Änderungen, die zu einem Ergebnis von einem anderen Cursor festlegen.<br /><br /> Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SENSITIVITY und die andere Cursorattribute finden Sie unter [Cursoreigenschaften und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Ein SQLULEN-Wert, der den Cursor angibt:<br /><br /> SQL_CURSOR_FORWARD_ONLY = der Cursor nur einen Bildlauf vorwärts.<br /><br /> SQL_CURSOR_STATIC = die Daten in das Ergebnis ist statisch.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = der Treiber gespeichert und verwendet die Schlüssel für die Anzahl der Zeilen, die in das Anweisungsattribut SQL_ATTR_KEYSET_SIZE angegeben.<br /><br /> SQL_CURSOR_DYNAMIC = der Treiber gespeichert und nur die Schlüssel für die Zeilen im Rowset verwendet.<br /><br /> Der Standardwert ist SQL_CURSOR_FORWARD_ONLY. Dieses Attribut kann nicht angegeben werden, nachdem die SQL-Anweisung vorbereitet wurde.<br /><br /> Wenn der angegebene Cursortyp nicht von der Datenquelle unterstützt wird, wird der Treiber ersetzt einen anderer Cursortyp und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert). Für den gemischten oder dynamischen Cursor ersetzt der Treiber in der Reihenfolge, ein keysetgesteuerter oder statischer Cursor. Bei einem keysetgesteuerten Cursor ersetzt der Treiber einen static-Cursor.<br /><br /> Weitere Informationen zu scrollbare Cursortypen, finden Sie unter [scrollbare Cursortypen](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_TYPE und die andere Cursorattribute finden Sie unter [Cursoreigenschaften und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob die automatischer Auffüllung des IPD ausgeführt wird:<br /><br /> SQL_TRUE = Schaltet auf automatische Auffüllung des IPD nach einem Aufruf von **SQLPrepare**. SQL_FALSE = aktiviert die automatische Auffüllung des IPD nach einem Aufruf von **SQLPrepare**. (Eine Anwendung kann immer noch IPD-Feld-Informationen durch den Aufruf abrufen **SQLDescribeParam**, wenn unterstützt.) Der Standardwert des Attributs Anweisung SQL_ATTR_ENABLE_AUTO_IPD wird SQL_FALSE. Weitere Informationen finden Sie unter [automatische Auffüllung des IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Eine SQLLEN \* , verweist auf einen Lesezeichenwert für die binäre. Wenn **SQLFetchScroll** aufgerufen wird und *fFetchOrientation* gleich sql_fetch_bookmark auf, der Treiber übernimmt die Lesezeichenwert aus diesem Feld. Dieses Feld ist standardmäßig auf einen null-Zeiger. Weitere Informationen finden Sie unter [Scrollen durch Lesezeichen](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Der Wert zeigt dieses Feld wird nicht zum Löschen durch Lesezeichen verwendet, aktualisieren, indem Sie Lesezeichen oder Abrufen von Lesezeichen-Vorgängen in der **SQLBulkOperations**, das Verwenden von Lesezeichen im Rowset Puffer zwischengespeichert.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Das Handle für den Implementierungsparameterdeskriptor, Implementierungszeilendeskriptor. Der Wert dieses Attributs ist der Deskriptor zugeordnet, wenn die Anweisung ursprünglich zugeordnet wurde. Die Anwendung kann nicht über dieses Attribut festgelegt.<br /><br /> Dieses Attribut abgerufen werden kann, durch einen Aufruf von **SQLGetStmtAttr** , aber nicht festgelegt, durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Das Handle für den IRD. Der Wert dieses Attributs ist der Deskriptor zugeordnet, wenn die Anweisung ursprünglich zugeordnet wurde. Die Anwendung kann nicht über dieses Attribut festgelegt.<br /><br /> Dieses Attribut abgerufen werden kann, durch einen Aufruf von **SQLGetStmtAttr** , aber nicht festgelegt, durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Ein SQLULEN erstellt wurde, der die Anzahl der Zeilen im Keyset eines keysetgesteuerten Cursors angibt. Wenn die Keysetgröße 0 (Standard) ist, ist der Cursor Keyset-gesteuerten. Wenn die Keysetgröße größer als 0 ist, wird der Cursor (innerhalb des Keysets keysetgesteuerte und dynamische außerhalb der Keyset) kombiniert. Die Standardgröße der Keyset ist 0. Weitere Informationen zu keysetgesteuerten Cursorn finden Sie unter [keysetgesteuerte Cursor](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Wenn die angegebene Größe die maximale Keysetgröße überschreitet, wird der Treiber ersetzt die Größe und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert).<br /><br /> **SQLFetch** oder **SQLFetchScroll** gibt einen Fehler zurück, die Keysetgröße ist größer als 0 und kleiner als die Rowsetgröße.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, die maximale Menge der Daten, die der Treiber von einem Zeichen oder binäre Spalte zurückgibt. Wenn *ValuePtr* ist kleiner als die Länge der verfügbaren Daten, **SQLFetch** oder **SQLGetData** schneidet die Daten und gibt SQL_SUCCESS zurück. Wenn *ValuePtr* gleich 0 (Standard) ist, versucht Sie, dass des Treibers alle verfügbare Daten zurückgeben.<br /><br /> Wenn die angegebene Länge ist kleiner als die Mindestmenge an Daten, die die Datenquelle zurückgegeben werden kann oder größer als die maximale Menge der Daten, die die Datenquelle zurückgegeben werden kann, die Treiber ersetzt, der Wert und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert).<br /><br /> Der Wert dieses Attributs kann bei einem geöffneten Cursor festgelegt werden. jedoch die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurück (der Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurückgesetzt.<br /><br /> Dieses Attribut dient zur Reduzierung des Netzwerkverkehrs und sollten werden nur unterstützt, wenn die Datenquelle (im Gegensatz zu den Treiber) in einem Treiber mehreren Ebenen, die sie implementieren kann. Dieser Mechanismus sollten nicht von Anwendungen zum Abschneiden von Daten verwendet werden; um die empfangenen Daten abgeschnitten werden, sollte eine Anwendung die maximale Puffergröße Länge in angeben der *Pufferlänge* -Argument in **SQLBindCol** oder **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Ein SQLULEN-Wert, der für die maximale Anzahl von Zeilen zurückgeben an die Anwendung für eine **wählen** Anweisung. Wenn \* *ValuePtr* gleich 0 (Standard), der Treiber gibt alle Zeilen zurück.<br /><br /> Dieses Attribut ist dazu vorgesehen, um Netzwerkdatenverkehr zu reduzieren. Im Prinzip wird angewendet, wenn das Resultset erstellt wird, und das Resultset auf die erste beschränkt *ValuePtr* Zeilen. Wenn die Anzahl der Zeilen im Resultset übersteigt *ValuePtr*, das Resultset wird abgeschnitten.<br /><br /> SQL_ATTR_MAX_ROWS gilt für alle Resultsets, auf die *Anweisung*, einschließlich von Katalogfunktionen zurückgegeben wird. SQL_ATTR_MAX_ROWS richtet einen Maximalwert für den Wert der Zeilenanzahl Cursor.<br /><br /> Ein Treiber emuliert sollten SQL_ATTR_MAX_ROWS Verhalten für nicht **SQLFetch** oder **SQLFetchScroll** (sofern es sich um eine Gruppe größeneinschränkungen nicht in der Datenquelle implementiert werden können), wenn sie nicht garantieren kann, SQL_ATTR_ MAX_ROWS wird ordnungsgemäß implementiert werden.<br /><br /> Es ist treiberdefinierten gibt an, ob SQL_ATTR_MAX_ROWS Anweisungen als SELECT-Anweisungen (z. B. Katalogfunktionen) angewendet werden.<br /><br /> Der Wert dieses Attributs kann bei einem geöffneten Cursor festgelegt werden. jedoch die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurück (der Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurückgesetzt.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Ein SQLULEN-Wert, der bestimmt, wie die Zeichenfolgenargumente von Katalogfunktionen behandelt werden.<br /><br /> Wenn SQL_TRUE, das Zeichenfolgenargument von Katalogfunktionen als Bezeichner behandelt werden. Die Groß-/Kleinschreibung ist nicht signifikant. Der Treiber entfernt nachgestellten Leerzeichen als begrenzungsbezeichnern Zeichenfolgen und die Zeichenfolge in Großbuchstaben gefaltet wird. Für durch Trennzeichen getrennten Zeichenfolgen wird der Treiber entfernt keine führenden oder nachgestellten Leerzeichen und nimmt, was wörtlich zwischen den Trennzeichen ist. Wenn eins dieser Argumente auf einen null-Zeiger festgelegt ist, gibt die Funktion SQL_ERROR zurück, und SQLSTATE HY009 (Ungültige Verwendung von null-Zeiger).<br /><br /> Wenn SQL_FALSE, die Zeichenfolgenargumente von Katalogfunktionen nicht als Bezeichner behandelt werden. Die Groß-/Kleinschreibung spielt. Sie können entweder ein Suchmuster Zeichenfolge oder nicht, je nach dem Argument enthalten.<br /><br /> Der Standardwert ist SQL_FALSE.<br /><br /> Die *TableType* Argument **SQLTables**, der eine Liste von Werten akzeptiert wird durch dieses Attribut nicht beeinflusst.<br /><br /> SQL_ATTR_METADATA_ID kann auch auf der Verbindungsebene festgelegt werden. (Es und SQL_ATTR_ASYNC_ENABLE sind die einzige Anweisung-Attribute, die auch Verbindungsattribute sind.)<br /><br /> Weitere Informationen finden Sie unter [Argumente in Katalogfunktionen](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob der Treiber den SQL-Zeichenfolgen für Escapesequenzen suchen soll:<br /><br /> SQL_NOSCAN_OFF = Treiber Scans SQL-Zeichenfolgen für Escapesequenzen (Standard).<br /><br /> SQL_NOSCAN_ON = scannt der Treiber keine SQL-Zeichenfolgen für Escapesequenzen. Stattdessen sendet der Treiber die Anweisung direkt in der Datenquelle.<br /><br /> Weitere Informationen finden Sie unter [Escapesequenzen in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN *-Wert, der auf einem Offset, der hinzugefügt werden, auf die Zeiger auf die Bindung des dynamischen Parameter ändern, verweist. Wenn dieses Feld nicht Null ist, den Treiber dereferenziert den Zeiger, fügt den verweislosen Wert jedem der zurückgestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) hinzu, und die neuen Zeigerwerte verwendet Bei der Bindung. Es wird festgelegt, der standardmäßig null.<br /><br /> Der Offset für die Bindung wird immer direkt auf die SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR Felder hinzugefügt. Wenn der Offset in einen anderen Wert geändert wird, wird der neue Wert weiterhin direkt auf den Wert in das Deskriptorfeld hinzugefügt. Der neue Offset ist der Wert des Felds sowie alle früheren Offsets nicht hinzugefügt.<br /><br /> Weitere Informationen finden Sie unter [Parameter binden Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_BIND_OFFSET_PTR" im APD-Header fest.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Ein SQLULEN erstellt wurde-Wert, der die Ausrichtung der Bindung für dynamische Parameter zu verwendende angibt.<br /><br /> Dieses Feld ist auf SQL_PARAM_BIND_BY_COLUMN (Standardeinstellung) festgelegt, spaltenbezogene Bindungen auswählen.<br /><br /> Zum Auswählen der zeilenbezogenen Bindung wird dieses Feld festgelegt, auf die Länge der Struktur oder einer Instanz eines Puffers, der auf eine Gruppe von dynamischen Parameter gebunden wird. Die Länge muss Speicherplatz für alle gebundenen Parameter und möglicherweise vorhandene Auffüllzeichen der Struktur bzw. des Puffers, um sicherzustellen, dass bei der die Adresse des gebundenen Parameter mit der angegebenen Länge erhöht wird, wird das Ergebnis an den Anfang des gleichen Parameters in den nächsten zeigen enthalten Satz von Parametern. Bei Verwendung der *"sizeof"* -Operator in ANSI C, wird dieses Verhalten garantiert.<br /><br /> Weitere Informationen finden Sie unter [Arrays der Bindungsparameter](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ BIND_TYPE" im APD-Header fest.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von Werten der SQLUSMALLINT zeigt verwendet, um einen Parameter während der Ausführung einer SQL­Anweisung zu ignorieren. Jeder Wert wird entweder SQL_PARAM_PROCEED (für den Parameter, die ausgeführt werden) oder SQL_PARAM_IGNORE (für den Parameter ignoriert werden soll) festgelegt.<br /><br /> Ein Satz von Parametern kann während der Verarbeitung ignoriert werden, durch den Statuswert in das Array verweist SQL_DESC_ARRAY_STATUS_PTR im APD zu SQL_PARAM_IGNORE festlegen. Eine Reihe von Parametern wird verarbeitet, wenn der Statuswert auf SQL_PARAM_PROCEED festgelegt ist, oder wenn keine Elemente im Array festgelegt werden.<br /><br /> Diese Anweisungsattribut kann auf ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Parameter Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLExecDirect** oder **SQLExecute** aufgerufen wird.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundenen Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ARRAY_STATUS_PTR" im APD-Header fest.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von SQLUSMALLINT zeigt Werte enthält Statusinformationen für jede Zeile von Parameterwerten nach einem Aufruf von **SQLExecute** oder **SQLExecDirect**. Dieses Feld ist erforderlich, nur dann, wenn PARAMSET_SIZE größer als 1 ist.<br /><br /> Die Status-Werte können die folgenden Werte enthalten:<br /><br /> SQL_PARAM_SUCCESS: Die SQL-Anweisung wurde erfolgreich für diesen Satz von Parametern ausgeführt.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Die SQL-Anweisung wurde erfolgreich für diesen Satz von Parametern ausgeführt. Allerdings ist Warninformationen in die Diagnose-Datenstruktur verfügbar.<br /><br /> SQL_PARAM_ERROR: Fehler bei der Verarbeitung dieser Satz von Parametern. Zusätzliche Fehlerinformationen ist in der Datenstruktur für die Diagnose verfügbar.<br /><br /> SQL_PARAM_UNUSED: Dieses Parametersatzes war nicht verwendet werden, möglicherweise darauf zurückzuführen, dass einige vorherigen Parametersatz einen Fehler verursacht hat, der weitere Verarbeitung abgebrochen, oder da SQL_PARAM_IGNORE für diesen Satz von Parametern in das Array, das durch die SQL_ATTR_PARAM_OPERATION_PTR angegeben festgelegt wurde.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Der Treiber von Parameterarrays als monolithische Einheit behandelt und generiert daher keine derartige Fehlerinformationen.<br /><br /> Diese Anweisungsattribut kann auf ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Parameter Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLExecute** oder **SQLExecDirect** aufgerufen wird. Beachten Sie, dass das Festlegen dieses Attributs, das Output-Parameterverhalten, die vom Treiber implementierte auswirken kann.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Das Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ARRAY_STATUS_PTR" im IPD-Header fest.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Ein SQLULEN \* Datensatzfeldaustausch, der auf einen Puffer, in dem die Anzahl von Parametersätzen zurückgegeben, die verarbeitet wurden einschließlich Fehler, verweist. Keine Anzahl wird zurückgegeben, wenn dies ein null-Zeiger ist.<br /><br /> Das Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ROWS_PROCESSED_PTR" im IPD-Header fest.<br /><br /> Wenn der Aufruf von **SQLExecDirect** oder **SQLExecute** füllt die Puffer, die auf dieses Attribut gibt keine SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurück, die Inhalte des Puffers nicht definiert sind.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, die Anzahl der Werte für jeden Parameter. Wenn verweist SQL_ATTR_PARAMSET_SIZE größer als 1 ist, zeigen SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR von APD auf Arrays an. Die Kardinalität jedes Arrays ist gleich dem Wert dieses Felds.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundenen Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Das Festlegen dieses Attributs Anweisung legt Feld SQL_DESC_ARRAY_SIZE im APD-Header fest.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Ein SQLULEN-Wert entspricht der Anzahl der Sekunden für eine SQL-Anweisung, um vor der Rückgabe an die Anwendung auszuführen. Wenn *ValuePtr* ist gleich 0 (Standard), wird keine zeitliche Beschränkung.<br /><br /> Wenn das angegebene Timeout das maximale Timeout in der Datenquelle überschreitet oder kleiner als der minimale Timeout **SQLSetStmtAttr** ersetzt durch diesen Wert und gibt Sie SQLSTATE 01 s 02 (der Optionswert wurde geändert).<br /><br /> Beachten Sie, die die Anwendung nicht aufrufen muss **SQLCloseCursor** , die Anweisung erneut zu verwenden, wenn eine **wählen** Anweisung abgelaufen.<br /><br /> Das Abfragetimeout in dieser Anweisungsattribut festgelegt ist im Modus für synchrone und asynchrone gültig.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Ein Wert SQLULEN erstellt wurde:<br /><br /> SQL_RD_ON = **SQLFetchScroll** und in ODBC *3.x*, **SQLFetch** Abrufen von Daten, nachdem die Position des Cursors am angegebenen Speicherort. Dies ist die Standardeinstellung.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** und in ODBC *3.x*, **SQLFetch** Daten nicht abrufen, nachdem die Position des Cursors.<br /><br /> Wenn SQL_RETRIEVE_DATA auf SQL_RD_OFF festlegen, überprüfen eine Anwendung, ob eine Zeile vorhanden ist oder ein Lesezeichen für die Zeile abrufen, ohne den Mehraufwand zum Abrufen von Zeilen. Weitere Informationen finden Sie unter [Bildlauf und Abrufen von Zeilen](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Der Wert dieses Attributs kann bei einem geöffneten Cursor festgelegt werden. jedoch die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurück (der Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurückgesetzt.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Ein SQLULEN erstellt wurde-Wert, der angibt, die Anzahl der Zeilen, die von jedem Aufruf zurückgegebenen **SQLFetch** oder **SQLFetchScroll**. Es ist auch die Anzahl der Zeilen in einem Lesezeichen-Array, das verwendet wird, in einem Massenvorgang für die Lesezeichen in **SQLBulkOperations**. Der Standardwert ist 1.<br /><br /> Überschreitet die Größe des angegebenen Rowsets die maximale Rowsetgröße, die von der Datenquelle unterstützt, wird der Treiber ersetzt diesen Wert und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert).<br /><br /> Weitere Informationen finden Sie unter [Rowsetgröße](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Durch Festlegen dieses Attributs für die Anweisung wird das Feld SQL_DESC_ARRAY_SIZE im ARD Header.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN *-Wert, der auf einem Offset, der hinzugefügt werden, auf die Zeiger auf die Bindung der Spaltendaten ändern, verweist. Wenn dieses Feld nicht Null ist, den Treiber dereferenziert den Zeiger, fügt den verweislosen Wert jedem der zurückgestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) hinzu, und die neuen Zeigerwerte verwendet Bei der Bindung. Es wird festgelegt, der standardmäßig null.<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_BIND_OFFSET_PTR" im Header ARD fest.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Ein SQLULEN-Wert, der die Ausrichtung der Bindung festlegt zu verwendende **SQLFetch** oder **SQLFetchScroll** für die zugeordnete Anweisung aufgerufen wird. Die spaltenweise Bindung wird durch Festlegen des Werts auf SQL_BIND_BY_COLUMN ausgewählt. Zeilenweise Bindung wird durch Festlegen des Werts auf die Länge einer Struktur oder eine Instanz eines Puffers, die in den Ergebnisspalten gebunden werden ausgewählt.<br /><br /> Wenn eine Länge angegeben wird, muss enthalten sein Speicherplatz für alle gebundenen Spalten und möglicherweise vorhandene Auffüllzeichen der Struktur bzw. des Puffers, um sicherzustellen, dass bei der die Adresse einer gebundenen Spalte mit der angegebenen Länge erhöht wird, wird das Ergebnis an den Anfang derselben Spalte in te zeigen e-nächste Zeile. Bei Verwendung der **"sizeof"** -Operator mit Struktur- oder Union in ANSI C, wird dieses Verhalten garantiert.<br /><br /> Die spaltenweise Bindung ist die Bindung standardausrichtung **SQLFetch** und **SQLFetchScroll**.<br /><br /> Weitere Informationen finden Sie unter [Binden von Spalten für die Verwendung mit Blockcursorn](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_BIND_TYPE" im Header ARD fest.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Ein SQLULEN-Wert, der die Anzahl der aktuellen Zeile in das gesamte Resultset festgelegt. Wenn die Anzahl der aktuellen Zeile kann nicht bestimmt werden, oder keine aktuelle Zeile vorhanden ist, gibt der Treiber 0 zurück.<br /><br /> Dieses Attribut abgerufen werden kann, durch einen Aufruf von **SQLGetStmtAttr** , aber nicht festgelegt, durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von Werten der SQLUSMALLINT zeigt verwendet, um eine Zeile während einer Operation mithilfe zu ignorieren **SQLSetPos**. Jeder Wert wird entweder SQL_ROW_PROCEED (für die Zeile in der Bulk-Vorgang einbezogen werden) oder SQL_ROW_IGNORE (für die Zeile aus den Massenvorgang ausgeschlossen werden sollen) festgelegt. (Zeilen nicht ignoriert werden, mithilfe dieses Array während des Aufrufs **SQLBulkOperations**.)<br /><br /> Diese Anweisungsattribut kann auf ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Zeile Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLSetPos** aufgerufen wird.<br /><br /> Weitere Informationen finden Sie unter [Aktualisieren von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) und [Löschen von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ARRAY_STATUS_PTR" in der ARD fest.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von SQLUSMALLINT zeigt Werte mit Zeilenwerten Status nach einem Aufruf von **SQLFetch** oder **SQLFetchScroll**. Das Array hat so viele Elemente als Zeilen im Rowset vorhanden sind.<br /><br /> Diese Anweisungsattribut kann auf ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Zeile Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, oder  **SQLSetPos** aufgerufen wird.<br /><br /> Weitere Informationen finden Sie unter [abgerufen, Anzahl von Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ARRAY_STATUS_PTR" in den IRD-Header fest.<br /><br /> Dieses Attribut zugeordnet ist, die von einer ODBC *2.x* -Treiber die *RgbRowStatus* Array in einem Aufruf von **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Ein SQLULEN \* Wert, der auf einen Puffer, in dem die Anzahl der nach einem Aufruf von abgerufenen Zeilen zurückgegeben. zeigt **SQLFetch** oder **SQLFetchScroll**; die Anzahl der Zeilen, die einen Massenvorgang betroffen durch einen Aufruf von **SQLSetPos** mit einer *Vorgang* Argument SQL_REFRESH; oder die Anzahl der Zeilen, die einen Massenvorgang wurden betroffen **SQLBulkOperations**. Diese Zahl beinhaltet Fehlerzeilen.<br /><br /> Weitere Informationen finden Sie unter [abgerufen, Anzahl von Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das Feld "SQL_DESC_ROWS_PROCESSED_PTR" in den IRD-Header fest.<br /><br /> Wenn der Aufruf von **SQLFetch** oder **SQLFetchScroll** füllt die Puffer, die auf dieses Attribut gibt keine SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurück, die Inhalte des Puffers nicht definiert sind.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob die Treiber, die simulieren positioniertes Update und delete-Anweisungen, garantieren, dass sich diese Anweisungen nur eine einzelne Zeile auswirken.<br /><br /> Um simulieren positioniertes Update und delete-Anweisungen, die meisten Treiber erstellen Sie einen komplexen **aktualisieren** oder **löschen** -Anweisung mit eine **, in denen** -Klausel, in der der Wert der einzelnen Spalten in der aktuellen Zeile. Es sei denn, diese Spalten einen eindeutigen Schlüssel bilden, kann eine solche Anweisung mehrere Zeilen auswirken.<br /><br /> Um sicherzustellen, dass diese Anweisungen nur eine Zeile betreffen, wird der Treiber bestimmt die Spalten in einen eindeutigen Schlüssel und das Resultset auf diese Spalten hinzugefügt. Wenn eine Anwendung wird sichergestellt, dass die Spalten im Resultset um einen eindeutigen Schlüssel machen, muss der Treiber nicht dazu. Dies kann sich die Ausführungszeit reduzieren.<br /><br /> SQL_SC_NON_UNIQUE = den Treiber ist nicht garantiert, die simulierte positioniert Update oder Delete-Anweisungen wirkt sich nur eine Zeile. Es ist Aufgabe der Anwendung dazu. Wenn eine Anweisung mehrere Zeilen betrifft **SQLExecute**, **SQLExecDirect**, oder **SQLSetPos** SQLSTATE 01001 (Konflikt beim Cursorvorgang) zurückgibt.<br /><br /> SQL_SC_TRY_UNIQUE = der Treiber versucht zu gewährleisten, die simulierte Update positioniert oder Anweisungen wirkt sich nur eine Zeile zu löschen. Der Treiber führt immer solchen Aussagen ist, auch wenn sie mehr als eine Zeile, z. B. wenn beeinflussen können keine eindeutiger Schlüssel vorhanden ist. Wenn eine Anweisung mehrere Zeilen betrifft **SQLExecute**, **SQLExecDirect**, oder **SQLSetPos** SQLSTATE 01001 (Konflikt beim Cursorvorgang) zurückgibt.<br /><br /> SQL_SC_UNIQUE = der Treiber gewährleistet, dass die simulierte positioniertes Update oder Anweisungen wirkt sich nur eine Zeile zu löschen. Wenn der Treiber dies für eine angegebene Anweisung nicht garantieren kann **SQLExecDirect** oder **SQLPrepare** gibt einen Fehler zurück.<br /><br /> Wenn native SQL-Unterstützung für positioniertes Update und delete-Anweisungen und simuliert des Treibers keine Cursor von der Datenquelle bereitgestellt, wird SQL_SUCCESS zurückgegeben, wenn SQL_SC_UNIQUE für SQL_SIMULATE_CURSOR angefordert wird. Wenn SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE angefordert wird, wird SQL_SUCCESS_WITH_INFO zurückgegeben. Wenn die Datenquelle das SQL_SC_TRY_UNIQUE Maß an Unterstützung stellt und der Treiber nicht, wird SQL_SUCCESS zurückgegeben, für für SQL_SC_NON_UNIQUE SQL_SC_TRY_UNIQUE und SQL_SUCCESS_WITH_INFO zurückgegeben.<br /><br /> Wenn der Typ des angegebenen Cursors Simulation von der Datenquelle nicht unterstützt wird, wird der Treiber ersetzt durch einen anderen Simulation-Typ und gibt SQLSTATE 01 s 02 (der Optionswert wurde geändert). Für SQL_SC_UNIQUE ersetzt der Treiber in der Reihenfolge, SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE. Für SQL_SC_TRY_UNIQUE ersetzt der Treiber SQL_SC_NON_UNIQUE.<br /><br /> Der Standardwert ist SQL_SC_UNIQUE.<br /><br /> Weitere Informationen finden Sie unter [simulieren positioniert Update- und Delete-Anweisungen](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob eine Anwendung Lesezeichen mit einem Cursor verwendet:<br /><br /> SQL_UB_OFF = Off (Standardeinstellung)<br /><br /> SQL_UB_VARIABLE = eine Anwendung mit einem Cursor Lesezeichen verwenden, und der Treiber wird variabler Länge, die Lesezeichen bereit, wenn sie unterstützt werden. SQL_UB_FIXED veraltetes Feature in ODBC *3.x*. ODBC *3.x* Anwendungen sollten immer variabler Länge, die Lesezeichen verwenden, auch bei der Arbeit mit ODBC *2.x* Treiber (was nur 4 Byte umfassender, fester Länge Lesezeichen unterstützt). Dies ist, da ein fester Länge Lesezeichen nur ein Sonderfall eines Lesezeichens variabler Länge ist. Beim Arbeiten mit ODBC *2.x* -Treiber des Treiber-Managers ordnet SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Um Lesezeichen mit einem Cursor zu verwenden, muss die Anwendung dieses Attributs mit dem SQL_UB_VARIABLE Wert angeben, vor dem Öffnen des Cursors.<br /><br /> Weitere Informationen finden Sie unter [Abrufen von Lesezeichen](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] für diese Funktionen können asynchron aufgerufen werden, nur dann, wenn der Deskriptor einer Implementierung, nicht für einen Anwendungsdienst-Deskriptor ist.  
  
 Finden Sie unter [spaltenbezogene Bindungen](../../../odbc/reference/develop-app/column-wise-binding.md) und [zeilenbezogene Bindungen](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Verwandte Funktionen  
  
|Informationen zu|Finden Sie unter|  
|---------------------------|---------|  
|Anweisungsverarbeitung Abbrechen|[SQLCancel-Funktion](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Die Einstellung ein Verbindungsattribut zurückgeben|[SQLGetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Die Einstellung für ein Anweisungsattribut zurückgeben|[SQLGetStmtAttr-Funktion](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Ein Verbindungsattribut festlegen|[SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Ein einzelnes Feld des Deskriptors festlegen|[SQLSetDescField-Funktion](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Siehe auch  
 [ODBC-API-Referenz](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [ODBC-Headerdateien](../../../odbc/reference/install/odbc-header-files.md)
